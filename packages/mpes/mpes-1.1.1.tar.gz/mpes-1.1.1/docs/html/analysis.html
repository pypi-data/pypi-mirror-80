

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Analysis (mpes.analysis) &mdash; mpes 1.1.1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="mpes 1.1.1 documentation" href="index.html"/>
        <link rel="next" title="Band-mapping data classes (mpes.bandstructure)" href="bandstructure.html"/>
        <link rel="prev" title="File I/O &amp; Processing (mpes.fprocessing)" href="file_io.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> mpes
          

          
          </a>

          
            
            
              <div class="version">
                1.1.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Instructions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="I01_start.html">How to start</a></li>
<li class="toctree-l1"><a class="reference internal" href="I02_overview.html">Overview of modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="I03_usenotes.html">Usage notes</a></li>
</ul>
<p class="caption"><span class="caption-text">API documentation</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="base.html">Base classes  <code class="docutils literal notranslate"><span class="pre">(mpes.base)</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="file_io.html">File I/O &amp; Processing  <code class="docutils literal notranslate"><span class="pre">(mpes.fprocessing)</span></code></a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Analysis  <code class="docutils literal notranslate"><span class="pre">(mpes.analysis)</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="bandstructure.html">Band-mapping data classes  <code class="docutils literal notranslate"><span class="pre">(mpes.bandstructure)</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="visualization.html">Visualization  <code class="docutils literal notranslate"><span class="pre">(mpes.visualization)</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="utils.html">Utility functions  <code class="docutils literal notranslate"><span class="pre">(mpes.utils)</span></code></a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">mpes</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Analysis  <code class="docutils literal notranslate"><span class="pre">(mpes.analysis)</span></code></li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/analysis.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="analysis-mpes-analysis">
<h1>Analysis  <code class="docutils literal notranslate"><span class="pre">(mpes.analysis)</span></code><a class="headerlink" href="#analysis-mpes-analysis" title="Permalink to this headline">¶</a></h1>
<p>Data analysis pipeline including background removal, segmentation and fitting</p>
<span class="target" id="module-mpes.analysis"></span><p>&#64;author: R. Patrick Xian</p>
<dl class="py class">
<dt id="mpes.analysis.BoundedArea">
<em class="property">class </em><code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">BoundedArea</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">image</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">shape</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">subimage</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.BoundedArea" title="Permalink to this definition">¶</a></dt>
<dd><p>Bounded area object from a parametric equation.</p>
<dl class="py method">
<dt id="mpes.analysis.BoundedArea.mask">
<em class="property">property </em><code class="sig-name descname">mask</code><a class="headerlink" href="#mpes.analysis.BoundedArea.mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Subimage attribute as mask</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.BoundedArea.setBoundary">
<code class="sig-name descname">setBoundary</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pmz</span><span class="o">=</span><span class="default_value">'linear'</span></em>, <em class="sig-param"><span class="n">boundtype</span><span class="o">=</span><span class="default_value">'&gt;'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.BoundedArea.setBoundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Add bound to grid to redefine subgrid.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>pmz<span class="classifier">str | ‘linear’</span></dt><dd><p>Parametrization (pmz) of the decision boundary (‘linear’ or ‘circular’).</p>
</dd>
<dt>boundtype<span class="classifier">str | ‘&gt;’</span></dt><dd><p>Bound region specification (‘&gt;’ or ‘&lt;’).</p>
</dd>
</dl>
<p><a href="#id1"><span class="problematic" id="id2">**</span></a>kwds : keyword arguments</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.BoundedArea.subgrid">
<em class="property">property </em><code class="sig-name descname">subgrid</code><a class="headerlink" href="#mpes.analysis.BoundedArea.subgrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Substituent pixel coordinates of the image.</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.BoundedArea.toMask">
<code class="sig-name descname">toMask</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">inbound</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">exbound</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.BoundedArea.toMask" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a scaled mask from existing shape.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>inbound<span class="classifier">float | 1</span></dt><dd><p>Value for the pixels within the boundary.</p>
</dd>
<dt>exbound<span class="classifier">float | 0</span></dt><dd><p>Value for the pixels outside the boundary.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Return</dt>
<dd class="field-even"><dl class="simple">
<dt>modmask<span class="classifier">2d array</span></dt><dd><p>Modified mask as a 2d array.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.BoundedArea.view">
<code class="sig-name descname">view</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">origin</span><span class="o">=</span><span class="default_value">'lower'</span></em>, <em class="sig-param"><span class="n">cmap</span><span class="o">=</span><span class="default_value">'terrain_r'</span></em>, <em class="sig-param"><span class="n">axes</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.BoundedArea.view" title="Permalink to this definition">¶</a></dt>
<dd><p>Display the current mask.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>origin<span class="classifier">str | ‘lower’</span></dt><dd><p>Location of the image origin.</p>
</dd>
<dt>cmap<span class="classifier">str | ‘terrain_r’</span></dt><dd><p>Color map</p>
</dd>
<dt>axes<span class="classifier">bool | True</span></dt><dd><p>Axes visibility option in plot.</p>
</dd>
<dt><a href="#id3"><span class="problematic" id="id4">**</span></a>kwds<span class="classifier">keyword arguments</span></dt><dd><p>Additional arguments for <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot.imshow()</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="mpes.analysis.EnergyCalibrator">
<em class="property">class </em><code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">EnergyCalibrator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">biases</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">files</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">folder</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">file_sorting</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">traces</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">tof</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.EnergyCalibrator" title="Permalink to this definition">¶</a></dt>
<dd><p>Electron binding energy calibration workflow.</p>
<dl class="py method">
<dt id="mpes.analysis.EnergyCalibrator.addFeatures">
<code class="sig-name descname">addFeatures</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ranges</span></em>, <em class="sig-param"><span class="n">refid</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">traces</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">infer_others</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">mode</span><span class="o">=</span><span class="default_value">'append'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.addFeatures" title="Permalink to this definition">¶</a></dt>
<dd><p>Select or extract the equivalent landmarks (e.g. peaks) among all traces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>ranges<span class="classifier">list/tuple</span></dt><dd><p>Collection of feature detection ranges, within which an algorithm
(i.e. 1D peak detector) with look for the feature.</p>
</dd>
<dt>refid<span class="classifier">int | 0</span></dt><dd><p>Index of the reference trace (EDC).</p>
</dd>
<dt>traces<span class="classifier">2D array | None</span></dt><dd><p>Collection of energy dispersion curves (EDCs).</p>
</dd>
<dt>infer_others<span class="classifier">bool | True</span></dt><dd><p>Option to infer the feature detection range in other traces (EDCs) from a given one.</p>
</dd>
<dt>mode<span class="classifier">str | ‘append’</span></dt><dd><p>Specification on how to change the feature ranges (‘append’ or ‘replace’).</p>
</dd>
<dt><a href="#id5"><span class="problematic" id="id6">**</span></a>kwds<span class="classifier">keyword arguments</span></dt><dd><p>Dictionarized keyword arguments for trace alignment (See <code class="docutils literal notranslate"><span class="pre">self.findCorrespondence()</span></code>)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.EnergyCalibrator.calibrate">
<code class="sig-name descname">calibrate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">refid</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">['coeffs']</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.calibrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the functional mapping between time-of-flight and the energy
scale using optimization methods.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>refid<span class="classifier">int | 0</span></dt><dd><p>The reference trace index (an integer).</p>
</dd>
<dt>ret<span class="classifier">list | [‘coeffs’]</span></dt><dd><p>Options for return values (see <code class="docutils literal notranslate"><span class="pre">mpes.analysis.calibrateE()</span></code>).</p>
</dd>
<dt><a href="#id7"><span class="problematic" id="id8">**</span></a>kwds<span class="classifier">keyword arguments</span></dt><dd><p>See available keywords for <code class="docutils literal notranslate"><span class="pre">mpes.analysis.calibrateE()</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.EnergyCalibrator.dup">
<em class="property">property </em><code class="sig-name descname">dup</code><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.dup" title="Permalink to this definition">¶</a></dt>
<dd><p>The duplication number.</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.EnergyCalibrator.featureExtract">
<code class="sig-name descname">featureExtract</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ranges</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">traces</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.featureExtract" title="Permalink to this definition">¶</a></dt>
<dd><p>Select or extract the equivalent landmarks (e.g. peaks) among all traces.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p>ranges : list | None
traces : 2D array | None
<a href="#id9"><span class="problematic" id="id10">**</span></a>kwds : keyword arguments</p>
<blockquote>
<div><p>See available keywords in <code class="docutils literal notranslate"><span class="pre">mpes.analysis.peaksearch()</span></code>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.EnergyCalibrator.findCorrespondence">
<em class="property">static </em><code class="sig-name descname">findCorrespondence</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sig_still</span></em>, <em class="sig-param"><span class="n">sig_mov</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'dtw'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.findCorrespondence" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the correspondence between two 1D traces by alignment.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>sig_still, sig_mov<span class="classifier">1D array, 1D array</span></dt><dd><p>Input 1D signals.</p>
</dd>
<dt>method<span class="classifier">str | ‘dtw’</span></dt><dd><p>Method for 1D signal correspondence detection (‘dtw’ or ‘ptw’).</p>
</dd>
<dt><a href="#id11"><span class="problematic" id="id12">**</span></a>kwds<span class="classifier">keyword arguments</span></dt><dd><p>See available keywords for the following functions,
(1) <code class="docutils literal notranslate"><span class="pre">fastdtw.fastdtw()</span></code> (when <code class="docutils literal notranslate"><span class="pre">method=='dtw'</span></code>)
(2) <code class="docutils literal notranslate"><span class="pre">ptw.ptw.timeWarp()</span></code> (when <code class="docutils literal notranslate"><span class="pre">method=='ptw'</span></code>)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Return</dt>
<dd class="field-even"><dl class="simple">
<dt>pathcorr<span class="classifier">list</span></dt><dd><p>Pixel-wise path correspondences between two input 1D arrays (sig_still, sig_mov).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.EnergyCalibrator.nfiles">
<em class="property">property </em><code class="sig-name descname">nfiles</code><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.nfiles" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of loaded files.</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.EnergyCalibrator.normalize">
<code class="sig-name descname">normalize</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalize the spectra along an axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><a href="#id13"><span class="problematic" id="id14">**</span></a>kwds<span class="classifier">keyword arguments</span></dt><dd><p>See the keywords for <code class="docutils literal notranslate"><span class="pre">mpes.utils.normspec()</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.EnergyCalibrator.nranges">
<em class="property">property </em><code class="sig-name descname">nranges</code><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.nranges" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of specified feature ranges.</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.EnergyCalibrator.ntraces">
<em class="property">property </em><code class="sig-name descname">ntraces</code><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.ntraces" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of loaded/calculated traces.</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.EnergyCalibrator.read">
<code class="sig-name descname">read</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">form</span><span class="o">=</span><span class="default_value">'h5'</span></em>, <em class="sig-param"><span class="n">tracename</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">tofname</span><span class="o">=</span><span class="default_value">'ToF'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read traces (e.g. energy dispersion curves) from files.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>form<span class="classifier">str | ‘h5’</span></dt><dd><p>Format of the files (‘h5’ or ‘mat’).</p>
</dd>
<dt>tracename<span class="classifier">str | ‘’</span></dt><dd><p>Name of the group/attribute corresponding to the trace.</p>
</dd>
<dt>tofname<span class="classifier">str | ‘ToF’</span></dt><dd><p>Name of the group/attribute corresponding to the time-of-flight.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.EnergyCalibrator.saveParameters">
<code class="sig-name descname">saveParameters</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">form</span><span class="o">=</span><span class="default_value">'h5'</span></em>, <em class="sig-param"><span class="n">save_addr</span><span class="o">=</span><span class="default_value">'./energy'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.saveParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Save all the attributes of the workflow instance for later use
(e.g. energy scale conversion).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>form<span class="classifier">str | ‘h5’</span></dt><dd><p>The file format to save the attributes in (‘h5’/’hdf5’ or ‘mat’).</p>
</dd>
<dt>save_addr<span class="classifier">str | ‘./energy’</span></dt><dd><p>The filename to save the files with.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.EnergyCalibrator.view">
<code class="sig-name descname">view</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">traces</span></em>, <em class="sig-param"><span class="n">segs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">peaks</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">show_legend</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">display</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">backend</span><span class="o">=</span><span class="default_value">'matplotlib'</span></em>, <em class="sig-param"><span class="n">linekwds</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">linesegkwds</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">scatterkwds</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">legkwds</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.view" title="Permalink to this definition">¶</a></dt>
<dd><p>Display a plot showing line traces with annotation.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt>traces<span class="classifier">2d array</span></dt><dd><p>Matrix of traces to visualize.</p>
</dd>
<dt>segs<span class="classifier">list/tuple</span></dt><dd><p>Segments to be highlighted in the visualization.</p>
</dd>
<dt>peaks<span class="classifier">2d array</span></dt><dd><p>Peak positions for labelling the traces.</p>
</dd>
<dt>ret<span class="classifier">bool</span></dt><dd><p>Return specification.</p>
</dd>
<dt>backend<span class="classifier">str | ‘matplotlib’</span></dt><dd><p>Backend specification, choose between ‘matplotlib’ (static) or ‘bokeh’ (interactive).</p>
</dd>
<dt>linekwds<span class="classifier">dict | {}</span></dt><dd><p>Keyword arguments for line plotting (see <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot.plot()</span></code>).</p>
</dd>
<dt>scatterkwds<span class="classifier">dict | {}</span></dt><dd><p>Keyword arguments for scatter plot (see <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot.scatter()</span></code>).</p>
</dd>
<dt>legkwds<span class="classifier">dict | {}</span></dt><dd><p>Keyword arguments for legend (see <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot.legend()</span></code>).</p>
</dd>
<dt><a href="#id15"><span class="problematic" id="id16">**</span></a>kwds<span class="classifier">keyword arguments</span></dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 26%" />
<col style="width: 18%" />
<col style="width: 56%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>keyword</p></th>
<th class="head"><p>data type</p></th>
<th class="head"><p>meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>maincolor</p></td>
<td><p>str</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>labels</p></td>
<td><p>list</p></td>
<td><p>Labels for each curve</p></td>
</tr>
<tr class="row-even"><td><p>xaxis</p></td>
<td><p>1d array</p></td>
<td><p>x (horizontal) axis values</p></td>
</tr>
<tr class="row-odd"><td><p>title</p></td>
<td><p>str</p></td>
<td><p>Title of the plot</p></td>
</tr>
<tr class="row-even"><td><p>legend_location</p></td>
<td><p>str</p></td>
<td><p>Location of the plot legend</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="mpes.analysis.Model">
<em class="property">class </em><code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">Model</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">xvar</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.Model" title="Permalink to this definition">¶</a></dt>
<dd><p>Class of fitting curve models</p>
<dl class="py method">
<dt id="mpes.analysis.Model._costfunc">
<code class="sig-name descname">_costfunc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">inits</span></em>, <em class="sig-param"><span class="n">xv</span></em>, <em class="sig-param"><span class="n">form</span><span class="o">=</span><span class="default_value">'original'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.Model._costfunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the cost function of the optimization process</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.Model.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">inits</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'leastsq'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">fitkwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.Model.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the optimization</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.Model.model_eval">
<code class="sig-name descname">model_eval</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">params</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.Model.model_eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the fitting model with given parameters</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.Model.normalize">
<em class="property">static </em><code class="sig-name descname">normalize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.Model.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalize n-dimensional data</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.Model.partial_eval">
<code class="sig-name descname">partial_eval</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">params</span></em>, <em class="sig-param"><span class="n">part</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.Model.partial_eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate parts of a composite fitting model</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="mpes.analysis.MomentumCorrector">
<em class="property">class </em><code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">MomentumCorrector</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">image</span></em>, <em class="sig-param"><span class="n">rotsym</span><span class="o">=</span><span class="default_value">6</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector" title="Permalink to this definition">¶</a></dt>
<dd><p>Momentum distortion correction and momentum calibration workflow.</p>
<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector._featureUpdate">
<code class="sig-name descname">_featureUpdate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">center_det</span><span class="o">=</span><span class="default_value">'centroidnn'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector._featureUpdate" title="Permalink to this definition">¶</a></dt>
<dd><p>Update selected features.</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector._imageUpdate">
<code class="sig-name descname">_imageUpdate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector._imageUpdate" title="Permalink to this definition">¶</a></dt>
<dd><p>Update distortion-corrected images.</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.applyDeformation">
<code class="sig-name descname">applyDeformation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">image</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.applyDeformation" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the deformation field to a specified image slice.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>image<span class="classifier">2D array</span></dt><dd><p>Image slice to apply the deformation.</p>
</dd>
<dt>ret<span class="classifier">bool | True</span></dt><dd><p>Option to return the image after deformation.</p>
</dd>
<dt><a href="#id17"><span class="problematic" id="id18">**</span></a>kwds<span class="classifier">keyword arguments</span></dt><dd><dl class="field-list simple">
<dt class="field-odd">rdeform, cdeform</dt>
<dd class="field-odd"><p>2D array, 2D array | self.rdeform_field, self.cdeform_field
Row- and column-ordered deformation fields.</p>
</dd>
<dt class="field-even">interp_order</dt>
<dd class="field-even"><p>int | 1
Interpolation order.</p>
</dd>
<dt class="field-odd">others</dt>
<dd class="field-odd"><p>See <code class="docutils literal notranslate"><span class="pre">scipy.ndimage.map_coordinates()</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.calcGeometricDistances">
<code class="sig-name descname">calcGeometricDistances</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.calcGeometricDistances" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate geometric distances involving the center and the vertices.
Distances calculated include center-vertex and nearest-neighbor vertex-vertex distances.</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.calcSymmetryScores">
<code class="sig-name descname">calcSymmetryScores</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">symtype</span><span class="o">=</span><span class="default_value">'rotation'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.calcSymmetryScores" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the symmetry scores from geometric quantities.</p>
<dl class="field-list simple">
<dt class="field-odd">Paramters</dt>
<dd class="field-odd"><dl class="simple">
<dt>symtype<span class="classifier">str | ‘rotation’</span></dt><dd><p>Type of symmetry.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.calibrate">
<code class="sig-name descname">calibrate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">image</span></em>, <em class="sig-param"><span class="n">point_from</span></em>, <em class="sig-param"><span class="n">point_to</span></em>, <em class="sig-param"><span class="n">dist</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">'coeffs'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.calibrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Calibration of the momentum axes. Obtain all calibration-related values,
return only the ones requested.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>image<span class="classifier">2d array</span></dt><dd><p>Image slice to construct the calibration function.</p>
</dd>
<dt>point_from, point_to<span class="classifier">list/tuple, list/tuple</span></dt><dd><p>Pixel coordinates of the two special points in (row, col) ordering.</p>
</dd>
<dt>dist<span class="classifier">float</span></dt><dd><p>Distance between the two selected points in inverse Angstrom.</p>
</dd>
<dt>ret<span class="classifier">str | ‘coeffs’</span></dt><dd><p>Specification of return values (‘axes’, ‘extent’, ‘coeffs’, ‘grid’, ‘func’, ‘all’).</p>
</dd>
<dt><a href="#id19"><span class="problematic" id="id20">**</span></a>kwds<span class="classifier">keyword arguments</span></dt><dd><p>See arguments in <code class="docutils literal notranslate"><span class="pre">mpes.analysis.calibrateE()</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Return</dt>
<dd class="field-even"><p>Specified calibration parameters in a dictionary.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.coordinateTransform">
<code class="sig-name descname">coordinateTransform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">type</span></em>, <em class="sig-param"><span class="n">keep</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">interp_order</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">mapkwds</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.coordinateTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a pixel-wise coordinate transform to an image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>type<span class="classifier">str</span></dt><dd><p>Type of deformation to apply to image slice.</p>
</dd>
<dt>keep<span class="classifier">bool | False</span></dt><dd><p>Option to keep the specified coordinate transform.</p>
</dd>
<dt>ret<span class="classifier">bool | False</span></dt><dd><p>Option to return transformed image slice.</p>
</dd>
<dt>interp_order<span class="classifier">int | 1</span></dt><dd><p>Interpolation order for filling in missed pixels.</p>
</dd>
<dt>mapkwds<span class="classifier">dict | {}</span></dt><dd><p>Additional arguments passed to <code class="docutils literal notranslate"><span class="pre">scipy.ndimage.map_coordinates()</span></code>.</p>
</dd>
<dt><a href="#id21"><span class="problematic" id="id22">**</span></a>kwds<span class="classifier">keyword arguments</span></dt><dd><p>Additional arguments in specific deformation field. See <code class="docutils literal notranslate"><span class="pre">symmetrize.sym</span></code> module.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.correct">
<code class="sig-name descname">correct</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">axis</span></em>, <em class="sig-param"><span class="n">use_composite_transform</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">update</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">use_deform_field</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">updatekwds</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.correct" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a 2D transform to a stack of 2D images (3D) along a specific axis.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt>axis<span class="classifier">int</span></dt><dd><p>Axis for slice selection.</p>
</dd>
<dt>use_composite_transform<span class="classifier">bool | False</span></dt><dd><p>Option to use the composite transform involving the rotation.</p>
</dd>
<dt>update<span class="classifier">bool | False</span></dt><dd><p>Option to update the existing figure attributes.</p>
</dd>
<dt>use_deform_field<span class="classifier">bool | False</span></dt><dd><p>Option to use deformation field for distortion correction.</p>
</dd>
<dt><a href="#id23"><span class="problematic" id="id24">**</span></a>kwds<span class="classifier">keyword arguments</span></dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 14%" />
<col style="width: 20%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>keyword</p></th>
<th class="head"><p>data type</p></th>
<th class="head"><p>meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>image</p></td>
<td><p>2d array</p></td>
<td><p>3D image for correction</p></td>
</tr>
<tr class="row-odd"><td><p>dfield</p></td>
<td><p>list/tuple</p></td>
<td><p>row and column deformation field</p></td>
</tr>
<tr class="row-even"><td><p>warping</p></td>
<td><p>2d array</p></td>
<td><p>2D transform correction matrix</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.featureExtract">
<code class="sig-name descname">featureExtract</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">image</span></em>, <em class="sig-param"><span class="n">direction</span><span class="o">=</span><span class="default_value">'ccw'</span></em>, <em class="sig-param"><span class="n">type</span><span class="o">=</span><span class="default_value">'points'</span></em>, <em class="sig-param"><span class="n">center_det</span><span class="o">=</span><span class="default_value">'centroidnn'</span></em>, <em class="sig-param"><span class="n">symscores</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.featureExtract" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Extract features from the selected 2D slice.</dt><dd><p>Currently only point feature detection is implemented.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>image<span class="classifier">2d array</span></dt><dd><p>The image slice to extract features from.</p>
</dd>
<dt>direction<span class="classifier">str | ‘ccw’</span></dt><dd><p>The circular direction to reorder the features in (‘cw’ or ‘ccw’).</p>
</dd>
<dt>type<span class="classifier">str | ‘points’</span></dt><dd><p>The type of features to extract.</p>
</dd>
<dt>center_det<span class="classifier">str | ‘centroidnn’</span></dt><dd><p>Specification of center detection method (‘centroidnn’, ‘centroid’, None).</p>
</dd>
<dt><a href="#id25"><span class="problematic" id="id26">**</span></a>kwds<span class="classifier">keyword arguments</span></dt><dd><p>Extra keyword arguments for <code class="docutils literal notranslate"><span class="pre">symmetrize.pointops.peakdetect2d()</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.features">
<em class="property">property </em><code class="sig-name descname">features</code><a class="headerlink" href="#mpes.analysis.MomentumCorrector.features" title="Permalink to this definition">¶</a></dt>
<dd><p>Dictionary of detected features for the symmetrization process.
<code class="docutils literal notranslate"><span class="pre">self.features</span></code> is a derived attribute from existing ones.</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.getWarpFunction">
<em class="property">static </em><code class="sig-name descname">getWarpFunction</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.getWarpFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct warping function to apply to other datasets.
# TODO: turn this into a fully operational method.</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.importBinningParameters">
<code class="sig-name descname">importBinningParameters</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">parp</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.importBinningParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Import parameters of binning used for correction image from parallelHDF5Processor Class instance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p>parp: instance of the ParallelHDF5Processor class used for creation of the correction image</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.intensityTransform">
<code class="sig-name descname">intensityTransform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">type</span><span class="o">=</span><span class="default_value">'rot_sym'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.intensityTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply pixel-wise intensity transform.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>type<span class="classifier">str | ‘rot_sym’</span></dt><dd><p>Type of intensity transform.</p>
</dd>
</dl>
<p><a href="#id27"><span class="problematic" id="id28">**</span></a>kwds : keyword arguments</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.linWarpEstimate">
<code class="sig-name descname">linWarpEstimate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">weights</span><span class="o">=</span><span class="default_value">1, 1, 1</span></em>, <em class="sig-param"><span class="n">optfunc</span><span class="o">=</span><span class="default_value">'minimize'</span></em>, <em class="sig-param"><span class="n">optmethod</span><span class="o">=</span><span class="default_value">'Nelder-Mead'</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">warpkwds</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.linWarpEstimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the homography-based deformation field using landmark correspondences.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt>weights<span class="classifier">tuple/list/array | (1, 1, 1)</span></dt><dd><p>Weights added to the terms in the optimizer. The terms are assigned
to the cost functions of (1) centeredness, (2) center-vertex symmetry,
(3) vertex-vertex symmetry, respectively.</p>
</dd>
<dt>optfunc, optmethod<span class="classifier">str/func, str | ‘minimize’, ‘Nelder-Mead’</span></dt><dd><p>Name of the optimizer function and the optimization method.
See description in <code class="docutils literal notranslate"><span class="pre">mpes.analysis.sym.target_set_optimize()</span></code>.</p>
</dd>
<dt>ret<span class="classifier">bool | True</span></dt><dd><p>Specify if returning the corrected image slice.</p>
</dd>
<dt>warpkwds<span class="classifier">dictionary | {}</span></dt><dd><p>Additional arguments passed to <code class="docutils literal notranslate"><span class="pre">symmetrize.sym.imgWarping()</span></code>.</p>
</dd>
<dt><a href="#id29"><span class="problematic" id="id30">**</span></a>kwds<span class="classifier">keyword arguments</span></dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 14%" />
<col style="width: 16%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>keyword</p></th>
<th class="head"><p>data type</p></th>
<th class="head"><p>meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>niter</p></td>
<td><p>int</p></td>
<td><p>Maximum number of iterations</p></td>
</tr>
<tr class="row-odd"><td><p>landmarks</p></td>
<td><p>list/array</p></td>
<td><p>Symmetry landmarks selected for registration</p></td>
</tr>
<tr class="row-even"><td><p>fitinit</p></td>
<td><p>tuple/list</p></td>
<td><p>Initial conditions for fitting</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>
</dd>
<dt class="field-even">Return</dt>
<dd class="field-even"><p>Corrected 2D image slice (when <code class="docutils literal notranslate"><span class="pre">ret=True</span></code> is specified in the arguments).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.resetDeformation">
<code class="sig-name descname">resetDeformation</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.resetDeformation" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the deformation field.</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.rotate">
<code class="sig-name descname">rotate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">angle</span><span class="o">=</span><span class="default_value">'auto'</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate 2D image in the homogeneous coordinate.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt>angle<span class="classifier">float/str</span></dt><dd><p>Angle of rotation (specify ‘auto’ to use automated estimation).</p>
</dd>
<dt>ret<span class="classifier">bool | False</span></dt><dd><p>Return specification (True/False)</p>
</dd>
<dt><a href="#id31"><span class="problematic" id="id32">**</span></a>kwds<span class="classifier">keyword arguments</span></dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 13%" />
<col style="width: 18%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>keyword</p></th>
<th class="head"><p>data type</p></th>
<th class="head"><p>meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>image</p></td>
<td><p>2d array</p></td>
<td><p>2D image for correction</p></td>
</tr>
<tr class="row-odd"><td><p>center</p></td>
<td><p>tuple/list</p></td>
<td><p>pixel coordinates of the image center</p></td>
</tr>
<tr class="row-even"><td><p>scale</p></td>
<td><p>float</p></td>
<td><p>scaling factor in rotation</p></td>
</tr>
</tbody>
</table>
<p>See <code class="docutils literal notranslate"><span class="pre">symmetrize.sym.sym_pose_estimate()</span></code> for other keywords.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.saveImage">
<code class="sig-name descname">saveImage</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">form</span><span class="o">=</span><span class="default_value">'tiff'</span></em>, <em class="sig-param"><span class="n">save_addr</span><span class="o">=</span><span class="default_value">'./'</span></em>, <em class="sig-param"><span class="n">dtyp</span><span class="o">=</span><span class="default_value">'float32'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.saveImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the distortion-corrected dataset (image only, without axes).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>form<span class="classifier">str | ‘tiff’</span></dt><dd><p>File format for saving the corrected image (‘tiff’ or ‘mat’).</p>
</dd>
<dt>save_addr<span class="classifier">str | ‘./’</span></dt><dd><p>The address to save the file at.</p>
</dd>
<dt>dtyp<span class="classifier">str | ‘float32’</span></dt><dd><p>Data type (in case conversion if needed).</p>
</dd>
<dt><a href="#id33"><span class="problematic" id="id34">**</span></a>kwds<span class="classifier">keyword arguments</span></dt><dd><p>See keywords from <code class="docutils literal notranslate"><span class="pre">tifffile.imsave()</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.saveParameters">
<code class="sig-name descname">saveParameters</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">form</span><span class="o">=</span><span class="default_value">'h5'</span></em>, <em class="sig-param"><span class="n">save_addr</span><span class="o">=</span><span class="default_value">'./momentum'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.saveParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Save all the attributes of the workflow instance for later use
(e.g. momentum scale conversion, reconstructing the warping map function).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>form<span class="classifier">str | ‘h5’</span></dt><dd><p>File format to for saving the parameters (‘h5’/’hdf5’, ‘mat’)</p>
</dd>
<dt>save_addr<span class="classifier">str | ‘./momentum’</span></dt><dd><p>The address for the to be saved file.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.selectSlice2D">
<code class="sig-name descname">selectSlice2D</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">selector</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.selectSlice2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Select (hyper)slice from a (hyper)volume.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>selector<span class="classifier">slice object/list/int</span></dt><dd><p>Selector along the specified axis to extract the slice (image).
Use the construct slice(start, stop, step) to select a range of images and sum them.
Use an integer to specify only a particular slice.</p>
</dd>
<dt>axis<span class="classifier">int | 2</span></dt><dd><p>Axis along which to select the image.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.splineWarpEstimate">
<code class="sig-name descname">splineWarpEstimate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">image</span></em>, <em class="sig-param"><span class="n">include_center</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">fixed_center</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">iterative</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">interp_order</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">update</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.splineWarpEstimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the spline deformation field using thin plate spline registration.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>image<span class="classifier">2D array</span></dt><dd><p>Image slice to be corrected.</p>
</dd>
<dt>include_center<span class="classifier">bool | True</span></dt><dd><p>Option to include the image center/centroid in the registration process.</p>
</dd>
<dt>fixed_center<span class="classifier">bool | True</span></dt><dd><p>Option to have a fixed center during registration-based symmetrization.</p>
</dd>
<dt>iterative<span class="classifier">bool | False</span></dt><dd><p>Option to use the iterative approach (may not work in all cases).</p>
</dd>
<dt>interp_order<span class="classifier">int | 1</span></dt><dd><p>Order of interpolation (see <code class="docutils literal notranslate"><span class="pre">scipy.ndimage.map_coordinates()</span></code>).</p>
</dd>
<dt>update<span class="classifier">bool | False</span></dt><dd><p>Option to keep the spline-deformed image as corrected one.</p>
</dd>
<dt>ret<span class="classifier">bool | False</span></dt><dd><p>Option to return corrected image slice.</p>
</dd>
<dt><a href="#id35"><span class="problematic" id="id36">**</span></a>kwds<span class="classifier">keyword arguments</span></dt><dd><dl class="field-list simple">
<dt class="field-odd">landmarks</dt>
<dd class="field-odd"><p>list/array | self.pouter_ord
Landmark positions (row, column) used for registration.</p>
</dd>
<dt class="field-even">new_centers</dt>
<dd class="field-even"><p>dict | {}
User-specified center positions for the reference and target sets.
{‘lmkcenter’: (row, col), ‘targcenter’: (row, col)}</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.symscores">
<em class="property">property </em><code class="sig-name descname">symscores</code><a class="headerlink" href="#mpes.analysis.MomentumCorrector.symscores" title="Permalink to this definition">¶</a></dt>
<dd><p>Dictionary of symmetry-related scores.</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.transform">
<em class="property">static </em><code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em>, <em class="sig-param"><span class="n">transmat</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Coordinate transform of a point set in the (row, column) formulation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>points<span class="classifier">list/array</span></dt><dd><p>Cartesian pixel coordinates of the points to be transformed.</p>
</dd>
<dt>transmat<span class="classifier">2D array</span></dt><dd><p>The transform matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Return</dt>
<dd class="field-even"><p>Transformed point coordinates.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.update">
<code class="sig-name descname">update</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">content</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update specific attributes of the class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>content<span class="classifier">str | ‘all’</span></dt><dd><p>‘feature’ = update only feature attributes
‘image’ = update only image-related attributes
‘all’ = update both feature and image-related attributes</p>
</dd>
<dt><a href="#id37"><span class="problematic" id="id38">**</span></a>kwds<span class="classifier">keyword arguments</span></dt><dd><p>Extra keyword arguments passed into <code class="docutils literal notranslate"><span class="pre">self._featureUpdate()</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.updateDeformation">
<code class="sig-name descname">updateDeformation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rdeform</span></em>, <em class="sig-param"><span class="n">cdeform</span></em>, <em class="sig-param"><span class="n">reset</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.updateDeformation" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the deformation field.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>rdeform, cdeform<span class="classifier">2D array, 2D array</span></dt><dd><p>Row- and column-ordered deformation fields.</p>
</dd>
<dt>reset<span class="classifier">bool | False</span></dt><dd><p>Option to reset the deformation field.</p>
</dd>
<dt><a href="#id39"><span class="problematic" id="id40">**</span></a>kwds<span class="classifier">keyword arguments</span></dt><dd><p>See <code class="docutils literal notranslate"><span class="pre">mpes.analysis.MomentumCorrector.resetDeformation()</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.view">
<code class="sig-name descname">view</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">origin</span><span class="o">=</span><span class="default_value">'lower'</span></em>, <em class="sig-param"><span class="n">cmap</span><span class="o">=</span><span class="default_value">'terrain_r'</span></em>, <em class="sig-param"><span class="n">figsize</span><span class="o">=</span><span class="default_value">4, 4</span></em>, <em class="sig-param"><span class="n">points</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">annotated</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">display</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">backend</span><span class="o">=</span><span class="default_value">'matplotlib'</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">imkwds</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">scatterkwds</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">crosshair</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">radii</span><span class="o">=</span><span class="default_value">[50, 100, 150]</span></em>, <em class="sig-param"><span class="n">crosshair_thickness</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.view" title="Permalink to this definition">¶</a></dt>
<dd><p>Display image slice with specified annotations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>origin<span class="classifier">str | ‘lower’</span></dt><dd><p>Figure origin specification (‘lower’ or ‘upper’).</p>
</dd>
<dt>cmap<span class="classifier">str | ‘terrain_r’</span></dt><dd><p>Colormap specification.</p>
</dd>
<dt>figsize<span class="classifier">tuple/list | (4, 4)</span></dt><dd><p>Figure size.</p>
</dd>
<dt>points<span class="classifier">dict | {}</span></dt><dd><p>Points for annotation.</p>
</dd>
<dt>annotated<span class="classifier">bool | False</span></dt><dd><p>Option for annotation.</p>
</dd>
<dt>display<span class="classifier">bool | True</span></dt><dd><p>Display option when using <code class="docutils literal notranslate"><span class="pre">bokeh</span></code> to render interactively.</p>
</dd>
<dt>backend<span class="classifier">str | ‘matplotlib’</span></dt><dd><p>Visualization backend specification.
:’matplotlib’: use static display rendered by matplotlib.
:’bokeh’: use interactive display rendered by bokeh.</p>
</dd>
<dt>ret<span class="classifier">bool | False</span></dt><dd><p>Option to return figure and axis objects.</p>
</dd>
<dt>imkwd<span class="classifier">dict | {}</span></dt><dd><p>Keyword arguments for <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot.imshow()</span></code>.</p>
</dd>
<dt>crosshair<span class="classifier">bool | False</span></dt><dd><p>Display option to plot circles around center self.pcent. Works only in bokeh backend.</p>
</dd>
<dt>radii<span class="classifier">list  |  [50,100,150]</span></dt><dd><p>Radii of circles to plot when crosshair optin is activated.</p>
</dd>
<dt>crosshair_thickness<span class="classifier">int  |  1</span></dt><dd><p>Thickness of crosshair circles.</p>
</dd>
<dt><a href="#id41"><span class="problematic" id="id42">**</span></a>kwds<span class="classifier">keyword arguments</span></dt><dd><p>General extra arguments for the plotting procedure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="mpes.analysis._datacheck_peakdetect">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">_datacheck_peakdetect</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_axis</span></em>, <em class="sig-param"><span class="n">y_axis</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis._datacheck_peakdetect" title="Permalink to this definition">¶</a></dt>
<dd><p>Input format checking</p>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis._rotate2d">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">_rotate2d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">image</span></em>, <em class="sig-param"><span class="n">center</span></em>, <em class="sig-param"><span class="n">angle</span></em>, <em class="sig-param"><span class="n">scale</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis._rotate2d" title="Permalink to this definition">¶</a></dt>
<dd><p>2D matrix scaled rotation carried out in the homogenous coordinate.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>image<span class="classifier">2d array</span></dt><dd><p>Image matrix.</p>
</dd>
<dt>center<span class="classifier">tuple/list</span></dt><dd><p>Center of the image (row pixel, column pixel).</p>
</dd>
<dt>angle<span class="classifier">numeric</span></dt><dd><p>Angle of image rotation.</p>
</dd>
<dt>scale<span class="classifier">numeric | 1</span></dt><dd><p>Scale of image rotation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>image_rot<span class="classifier">2d array</span></dt><dd><p>Rotated image matrix.</p>
</dd>
<dt>rotmat<span class="classifier">2d array</span></dt><dd><p>Rotation matrix in the homogeneous coordinate system.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis._signedmask">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">_signedmask</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">imr</span></em>, <em class="sig-param"><span class="n">imc</span></em>, <em class="sig-param"><span class="n">maskr</span></em>, <em class="sig-param"><span class="n">maskc</span></em>, <em class="sig-param"><span class="n">sign</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis._signedmask" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a binary mask using the masked coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>imr, imc<span class="classifier">int</span></dt><dd><p>Row and column size of the image.</p>
</dd>
<dt>maskr, maskc<span class="classifier">1D array</span></dt><dd><p>Row and column coordinates of the masked pixels.</p>
</dd>
<dt>sign<span class="classifier">int/str</span></dt><dd><p>Value of the masked region, (0, 1, ‘nan’, or ‘xnan’).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Return</dt>
<dd class="field-even"><dl class="simple">
<dt>mask<span class="classifier">2D array</span></dt><dd><p>Mask matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.applyWarping">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">applyWarping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">imgstack</span></em>, <em class="sig-param"><span class="n">axis</span></em>, <em class="sig-param"><span class="n">hgmat</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.applyWarping" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply warping transform for a stack of images along an axis</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>imgstack<span class="classifier">3D array</span></dt><dd><p>Image stack before warping correction.</p>
</dd>
<dt>axis<span class="classifier">int</span></dt><dd><p>Axis to iterate over to apply the transform.</p>
</dd>
<dt>hgmat<span class="classifier">2D array</span></dt><dd><p>Homography matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Return</dt>
<dd class="field-even"><dl class="simple">
<dt>imstack_transformed<span class="classifier">3D array</span></dt><dd><p>Stack of images after correction for warping.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.apply_mask_along">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">apply_mask_along</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arr</span></em>, <em class="sig-param"><span class="n">mask</span></em>, <em class="sig-param"><span class="n">axes</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.apply_mask_along" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a mask in a low dimensional slice throughout a high-dimensional array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>arr<span class="classifier">nD array</span></dt><dd><p>Multidimensional array for masking.</p>
</dd>
<dt>mask<span class="classifier">nD array</span></dt><dd><p>Mask to apply.</p>
</dd>
<dt>axes<span class="classifier">list/tuple of int | None</span></dt><dd><p>The axes to apply the mask to.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Return</dt>
<dd class="field-even"><dl class="simple">
<dt>maskedarr<span class="classifier">nD array</span></dt><dd><p>Masked multidimensional array.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.bandpath_map">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">bandpath_map</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">bsvol</span></em>, <em class="sig-param"><span class="n">pathr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">pathc</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">path_coords</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">eaxis</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'analog'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.bandpath_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract band diagram map from 2D/3D data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>bsvol<span class="classifier">2D/3D array</span></dt><dd><p>Volumetric band structure data.</p>
</dd>
<dt>pathr, pathc<span class="classifier">1D array | None, None</span></dt><dd><p>Row and column pixel coordinates along the band path (ignored if path_coords is given).</p>
</dd>
<dt>path_coords<span class="classifier">2D array | None</span></dt><dd><p>Combined row and column pixel coordinates of the band path.</p>
</dd>
<dt>eaxis<span class="classifier">int | 2</span></dt><dd><p>Energy axis index.</p>
</dd>
<dt>method<span class="classifier">str | ‘analog’</span></dt><dd><p>Method for generating band path map (‘analog’ or ‘digital’).
:’analog’: Using an interpolation scheme to calculate the exact pixel values.
:’digital’: Using only the approximating pixel values (Bresenham’s algorithm).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Return</dt>
<dd class="field-even"><dl class="simple">
<dt>bpm<span class="classifier">2D array</span></dt><dd><p>Band path map (BPM) sampled from the volumetric data.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.blocknorm">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">blocknorm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">mavg_axis</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">blockwidth</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.blocknorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Block-thresholding 2D data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>data<span class="classifier">ndarray</span></dt><dd><p>Data to normalize.</p>
</dd>
<dt>mavg_axis<span class="classifier">int | 0</span></dt><dd><p>Axis to move the block along.</p>
</dd>
<dt>blockwidth<span class="classifier">int | 1</span></dt><dd><p>Width of the moving block.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Return</dt>
<dd class="field-even"><dl class="simple">
<dt>datanorm<span class="classifier">ndarray</span></dt><dd><p>Block-normalized data.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.bootstrapfit">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">bootstrapfit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">axval</span></em>, <em class="sig-param"><span class="n">model</span></em>, <em class="sig-param"><span class="n">params</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">dfcontainer</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">pbar</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">pbenv</span><span class="o">=</span><span class="default_value">'classic'</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">'all'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.bootstrapfit" title="Permalink to this definition">¶</a></dt>
<dd><p>Line-by-line fitting via bootstrapping fitted parameters from one line to the next.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt>data<span class="classifier">ndarray</span></dt><dd><p>Data used in fitting.</p>
</dd>
<dt>axval<span class="classifier">list/numeric array</span></dt><dd><p>Value for the axis.</p>
</dd>
<dt>model<span class="classifier">lmfit Model object</span></dt><dd><p>The fitting model.</p>
</dd>
<dt>params<span class="classifier">lmfit Parameters object</span></dt><dd><p>Initial guesses for fitting parameters.</p>
</dd>
<dt>axis<span class="classifier">int | 0</span></dt><dd><p>The axis of the data to fit.</p>
</dd>
<dt>dfcontainer<span class="classifier">pandas DataFrame | None</span></dt><dd><p>Dataframe container for the fitting parameters.</p>
</dd>
<dt>pbar<span class="classifier">bool | False</span></dt><dd><p>Progress bar condition.</p>
</dd>
<dt>pbenv<span class="classifier">str | ‘classic’</span></dt><dd><p>Progress bar environment (‘classic’ for generic version, ‘notebook’ for
notebook compatible version).</p>
</dd>
<dt><a href="#id43"><span class="problematic" id="id44">**</span></a>kwds<span class="classifier">keyword arguments</span></dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 14%" />
<col style="width: 11%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>keyword</p></th>
<th class="head"><p>data type</p></th>
<th class="head"><p>meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>maxiter</p></td>
<td><p>int</p></td>
<td><p>maximum iteration per fit (default = 20)</p></td>
</tr>
<tr class="row-odd"><td><p>concat</p></td>
<td><p>bool</p></td>
<td><p>concatenate the fit parameters to DataFrame input
False (default) = no concatenation, use an empty DataFrame to start
True = with concatenation to input DataFrame</p></td>
</tr>
<tr class="row-even"><td><p>bgremove</p></td>
<td><p>bool</p></td>
<td><p>toggle for background removal (default = True)</p></td>
</tr>
<tr class="row-odd"><td><p>flipped</p></td>
<td><p>bool</p></td>
<td><p>toggle for fitting start position
(if flipped, fitting start from the last line)</p></td>
</tr>
<tr class="row-even"><td><p>limpropagate</p></td>
<td><p>bool</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>verbose</p></td>
<td><p>bool</p></td>
<td><p>toggle for output message (default = False)</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>df_fit<span class="classifier">pandas DataFrame</span></dt><dd><p>Dataframe container populated with obtained fitting parameters.</p>
</dd>
<dt>data_nobg<span class="classifier">ndarray</span></dt><dd><p>Background-removed (Shirley-type) traces.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.build_dynamic_matrix">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">build_dynamic_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fitparams</span></em>, <em class="sig-param"><span class="n">display_range</span><span class="o">=</span><span class="default_value">slice(None, None, None)</span></em>, <em class="sig-param"><span class="n">pre_t0_range</span><span class="o">=</span><span class="default_value">slice(None, 1, None)</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.build_dynamic_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct the dynamic matrix from the fitting results. For each fitting parameter, construct time-dependent value, time-dependent absolute and relative changes.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>fitparams: 3D ndarray</dt><dd><p>fitting output</p>
</dd>
<dt>display_range: slice object | slice(None, None, None)</dt><dd><p>display time range of the fitting parameters (default = full range)</p>
</dd>
<dt>pre_t0_range: slice object | slice(None, 1, None)</dt><dd><p>time range regarded as before time-zero</p>
</dd>
</dl>
<p><strong>Returns</strong></p>
<dl class="simple">
<dt>dyn_matrix<span class="classifier">4D ndarray</span></dt><dd><p>calculated dynamic matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.calibrateE">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">calibrateE</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pos</span></em>, <em class="sig-param"><span class="n">vals</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="n">refid</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">'func'</span></em>, <em class="sig-param"><span class="n">E0</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Eref</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">t</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">aug</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'lstsq'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.calibrateE" title="Permalink to this definition">¶</a></dt>
<dd><p>Energy calibration by nonlinear least squares fitting of spectral landmarks on
a set of (energy dispersion curves (EDCs). This amounts to solving for the
coefficient vector, a, in the system of equations T.a = b. Here T is the
differential drift time matrix and b the differential bias vector, and
assuming that the energy-drift-time relationship can be written in the form,
E = sum_n (a_n * t**n) + E0</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>pos<span class="classifier">list/array</span></dt><dd><p>Positions of the spectral landmarks (e.g. peaks) in the EDCs.</p>
</dd>
<dt>vals<span class="classifier">list/array</span></dt><dd><p>Bias voltage value associated with each EDC.</p>
</dd>
<dt>order<span class="classifier">int | 3</span></dt><dd><p>Polynomial order of the fitting function.</p>
</dd>
<dt>refid<span class="classifier">int | 0</span></dt><dd><p>Reference dataset index, varies from 0 to vals.size - 1.</p>
</dd>
<dt>ret<span class="classifier">str | ‘func’</span></dt><dd><p>Return type, including ‘func’, ‘coeffs’, ‘full’, and ‘axis’ (see below).</p>
</dd>
<dt>E0<span class="classifier">float | None</span></dt><dd><p>Constant energy offset.</p>
</dd>
<dt>t<span class="classifier">numeric array | None</span></dt><dd><p>Drift time.</p>
</dd>
<dt>aug<span class="classifier">int | 1</span></dt><dd><p>Fitting dimension augmentation (1=no change, 2=double, etc).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>pfunc<span class="classifier">partial function</span></dt><dd><p>Calibrating function with determined polynomial coefficients (except the constant offset).</p>
</dd>
<dt>ecalibdict<span class="classifier">dict</span></dt><dd><p>A dictionary of fitting parameters including the following,
:coeffs: Fitted polynomial coefficients (the a’s).
:offset: Minimum time-of-flight corresponding to a peak.
:Tmat: the T matrix (differential time-of-flight) in the equation Ta=b.
:bvec: the b vector (differential bias) in the fitting Ta=b.
:axis: Fitted energy axis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.calibrateK">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">calibrateK</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">img</span></em>, <em class="sig-param"><span class="n">pxla</span></em>, <em class="sig-param"><span class="n">pxlb</span></em>, <em class="sig-param"><span class="n">k_ab</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kcoorda</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kcoordb</span><span class="o">=</span><span class="default_value">[0.0, 0.0]</span></em>, <em class="sig-param"><span class="n">equiscale</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">['axes']</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.calibrateK" title="Permalink to this definition">¶</a></dt>
<dd><p>Momentum axes calibration using the pixel positions of two symmetry points (a and b)
and the absolute coordinate of a single point (b), defaulted to [0., 0.]. All coordinates
should be specified in the (row_index, column_index) format. See the equiscale option for
details on the specifications of point coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>img<span class="classifier">2D array</span></dt><dd><p>An energy cut of the band structure.</p>
</dd>
<dt>pxla, pxlb<span class="classifier">list/tuple/1D array</span></dt><dd><p>Pixel coordinates of the two symmetry points (a and b). Point b has the
default coordinates [0., 0.] (see below).</p>
</dd>
<dt>k_ab<span class="classifier">float | None</span></dt><dd><p>The known momentum space distance between the two symmetry points.</p>
</dd>
<dt>kcoorda<span class="classifier">list/tuple/1D array | None</span></dt><dd><p>Momentum coordinates of the symmetry point a.</p>
</dd>
<dt>kcoordb<span class="classifier">list/tuple/1D array | [0., 0.]</span></dt><dd><p>Momentum coordinates of the symmetry point b (krow, kcol), default to k-space center.</p>
</dd>
<dt>equiscale<span class="classifier">bool | False</span></dt><dd><p>Option to adopt equal scale along both the row and column directions.
:True: Use a uniform scale for both x and y directions in the image coordinate system.
This applies to the situation where the points a and b are (close to) parallel with one
of the two image axes.
:False: Calculate the momentum scale for both x and y directions separately. This applies
to the situation where the points a and b are sufficiently different in both x and y directions
in the image coordinate system.</p>
</dd>
<dt>ret<span class="classifier">list | [‘axes’]</span></dt><dd><p>Return type specification, options include ‘axes’, ‘extent’, ‘coeffs’, ‘grid’, ‘func’, ‘all’.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>k_row, k_col<span class="classifier">1D array</span></dt><dd><p>Momentum coordinates of the row and column.</p>
</dd>
<dt>axis_extent<span class="classifier">list</span></dt><dd><p>Extent of the two momentum axis (can be used directly in imshow).</p>
</dd>
<dt>k_rowgrid, k_colgrid<span class="classifier">2D array</span></dt><dd><p>Row and column mesh grid generated from the coordinates
(can be used directly in pcolormesh).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.circmask">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">circmask</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">img</span></em>, <em class="sig-param"><span class="n">rcent</span></em>, <em class="sig-param"><span class="n">ccent</span></em>, <em class="sig-param"><span class="n">rad</span></em>, <em class="sig-param"><span class="n">sign</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">'mask'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.circmask" title="Permalink to this definition">¶</a></dt>
<dd><p>Use a circular binary mask to cover an image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt>img<span class="classifier">2D array</span></dt><dd><p>Input image to be masked.</p>
</dd>
<dt>rcent<span class="classifier">float</span></dt><dd><p>Row center position.</p>
</dd>
<dt>ccent<span class="classifier">float</span></dt><dd><p>Column center position.</p>
</dd>
<dt>rad<span class="classifier">float</span></dt><dd><p>Radius of circle.</p>
</dd>
<dt>sign<span class="classifier">int/str | 1</span></dt><dd><p>Value of the masked region (0, 1, ‘nan’ or ‘xnan’).
‘xnan’ means the masked region is 1 and the other region nan.</p>
</dd>
<dt>ret<span class="classifier">str | ‘mask’</span></dt><dd><p>Return type (‘mask’, ‘masked_image’)</p>
</dd>
<dt>kwds<span class="classifier">keyword arguments</span></dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 22%" />
<col style="width: 17%" />
<col style="width: 20%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>keyword</p></th>
<th class="head"><p>data type</p></th>
<th class="head"><p>default</p></th>
<th class="head"><p>meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>shape</p></td>
<td><p>tuple/list</p></td>
<td><p>shape of img</p></td>
<td><p>see skimage.draw.circle()</p></td>
</tr>
<tr class="row-odd"><td><p>method</p></td>
<td><p>str</p></td>
<td><p>‘graphic’</p></td>
<td><p>‘graphic’ or ‘algebraic’</p></td>
</tr>
<tr class="row-even"><td><p>edgefactor</p></td>
<td><p>float</p></td>
<td><p>1.02</p></td>
<td><p>prefactor to rad**2</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>
</dd>
<dt class="field-even">Return</dt>
<dd class="field-even"><dl class="simple">
<dt>cmask or cmask*img<span class="classifier">2D array</span></dt><dd><p>Mask only or masked image</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.curvature2d">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">curvature2d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">image</span></em>, <em class="sig-param"><span class="n">cx</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">cy</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.curvature2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Implementation of 2D curvature calculation.
The formula follows Zhang et al. Rev. Sci. Instrum. 82, 043712 (2011).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>image<span class="classifier">2D array</span></dt><dd><p>2D image obtained from measurement.</p>
</dd>
<dt>cx, cy<span class="classifier">numeric, numeric | 1, 1</span></dt><dd><p>Scaling parameters in x and y directions.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.func_add">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">func_add</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">funcs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.func_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Addition of an arbitray number of functions</p>
<p><strong>*Parameters*</strong></p>
<dl class="simple">
<dt><a href="#id45"><span class="problematic" id="id46">*</span></a>funcs: list/tuple</dt><dd><p>functions to combine</p>
</dd>
</dl>
<p><strong>*Returns*</strong></p>
<dl class="simple">
<dt>funcsum: function</dt><dd><p>functional sum</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.func_update">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">func_update</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">suffix</span><span class="o">=</span><span class="default_value">''</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.func_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach a suffix to parameter names and their instances
in the expression of a function</p>
<p><strong>*Parameters*</strong></p>
<dl class="simple">
<dt>func: function</dt><dd><p>input function</p>
</dd>
<dt>suffix: str | ‘’</dt><dd><p>suffix to attach to parameter names</p>
</dd>
</dl>
<p><strong>*Returns*</strong></p>
<dl class="simple">
<dt>params: list of str</dt><dd><p>updated function parameters</p>
</dd>
<dt>expr: str</dt><dd><p>updated function expression</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.gaussian">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">gaussian</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">feval</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">vardict</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.gaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>1D Gaussian lineshape model. Returns numerical values if <code class="docutils literal notranslate"><span class="pre">feval=True</span></code>.</p>
<p><strong>Parameters</strong></p>
<dl>
<dt>feval: bool | False</dt><dd><p>Option to evaluate function.</p>
</dd>
<dt>vardict: dict | None</dt><dd><p>Dictionary containing values for the variables named as follows (as dictionary keys).</p>
<p><code class="docutils literal notranslate"><span class="pre">amp</span></code> function amplitude or scaling factor.</p>
<p><code class="docutils literal notranslate"><span class="pre">xvar</span></code> x values (energy values in a lineshape).</p>
<p><code class="docutils literal notranslate"><span class="pre">ctr</span></code> center position.</p>
<p><code class="docutils literal notranslate"><span class="pre">sig</span></code> standard deviation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.gradn">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">gradn</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">array</span></em>, <em class="sig-param"><span class="n">axes</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.gradn" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate nth-order gradients of the array along different directions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>array<span class="classifier">numpy array</span></dt><dd><p>N-dimensional matrix for calculating the gradient.</p>
</dd>
<dt>axes<span class="classifier">int/list/tuple/1D array</span></dt><dd><p>A sequence of axes (from first to last) to calculate the gradient.
When input a single integer, the gradient is calculated along that particular axis.
For example, the 4th-order mixed gradient d4f/(dxdydxdy) requires the sequence (1, 0, 1, 0).</p>
</dd>
<dt><a href="#id47"><span class="problematic" id="id48">**</span></a>kwds<span class="classifier">keyword arguments</span></dt><dd><p>See <code class="docutils literal notranslate"><span class="pre">numpy.gradient()</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.image_interpolator">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">image_interpolator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">image</span></em>, <em class="sig-param"><span class="n">iptype</span><span class="o">=</span><span class="default_value">'RGI'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.image_interpolator" title="Permalink to this definition">¶</a></dt>
<dd><p>Construction of an image interpolator.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>image: 2D array</dt><dd><p>2D image for interpolation.</p>
</dd>
<dt>iptype: str | ‘RGI’</dt><dd><p>Type of the interpolator.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>interp: interpolator instance</dt><dd><p>Instance of an interpolator.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.interp_slice">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">interp_slice</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">pathr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">pathc</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">path_coords</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">iptype</span><span class="o">=</span><span class="default_value">'RGI'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.interp_slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Slicing 2D/3D data through interpolation.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>data: 2D/3D array</dt><dd><p>Data array for slicing.</p>
</dd>
<dt>pathr, pathc: list/tuple/array, list/tuple/array</dt><dd><p>Row and column coordinates of the interpolated path.</p>
</dd>
<dt>path_coords: array</dt><dd><p>Cartesian coordinates of the interpolated path.</p>
</dd>
<dt>iptype: str | ‘RGI’</dt><dd><p>Type of interpolator.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.line_generator">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">line_generator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">B</span></em>, <em class="sig-param"><span class="n">npoints</span></em>, <em class="sig-param"><span class="n">endpoint</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">'separated'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.line_generator" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate intermediate points in a line segment AB (A to B) given endpoints.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>A, B<span class="classifier">tuple/list, tuple/list</span></dt><dd><p>Pixel coordinates of the endpoints of the line segment.</p>
</dd>
<dt>npoints<span class="classifier">numeric</span></dt><dd><p>Number of points in the line segment.</p>
</dd>
<dt>endpoint<span class="classifier">bool | True</span></dt><dd><p>Option to include the endpoint (B) in the line coordinates.</p>
</dd>
<dt>ret<span class="classifier">str | ‘separated’</span></dt><dd><p>Option to return line coordinates (‘separated’ or ‘joined’).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.peakdetect1d">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">peakdetect1d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_axis</span></em>, <em class="sig-param"><span class="n">x_axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">lookahead</span><span class="o">=</span><span class="default_value">200</span></em>, <em class="sig-param"><span class="n">delta</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.peakdetect1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Function for detecting local maxima and minima in a signal.
Discovers peaks by searching for values which are surrounded by lower
or larger values for maxima and minima respectively</p>
<p>Converted from/based on a MATLAB script at:
<a class="reference external" href="http://billauer.co.il/peakdet.html">http://billauer.co.il/peakdet.html</a></p>
<p><strong>Parameters</strong>
y_axis : list</p>
<blockquote>
<div><p>A list containing the signal over which to find peaks</p>
</div></blockquote>
<dl class="simple">
<dt>x_axis<span class="classifier">list | None</span></dt><dd><p>A x-axis whose values correspond to the y_axis list and is used
in the return to specify the position of the peaks. If omitted an
index of the y_axis is used.</p>
</dd>
<dt>lookahead<span class="classifier">int | 200</span></dt><dd><p>distance to look ahead from a peak candidate to determine if
it is the actual peak
‘(samples / period) / f’ where ‘4 &gt;= f &gt;= 1.25’ might be a good value</p>
</dd>
<dt>delta<span class="classifier">numeric | 0</span></dt><dd><p>this specifies a minimum difference between a peak and
the following points, before a peak may be considered a peak. Useful
to hinder the function from picking up false peaks towards to end of
the signal. To work well delta should be set to delta &gt;= RMSnoise * 5.</p>
</dd>
</dl>
<p><strong>Returns</strong>
max_peaks : list</p>
<blockquote>
<div><p>positions of the positive peaks</p>
</div></blockquote>
<dl class="simple">
<dt>min_peaks<span class="classifier">list</span></dt><dd><p>positions of the negative peaks</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.peakdetect2d">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">peakdetect2d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">img</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'daofind'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.peakdetect2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Peak-like feature detection in a 2D image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt>img<span class="classifier">2D array</span></dt><dd><p>Image matrix.</p>
</dd>
<dt>method<span class="classifier">str | ‘daofind’</span></dt><dd><p>Detection method (‘daofind’ or ‘maxlist’).</p>
</dd>
<dt><a href="#id49"><span class="problematic" id="id50">**</span></a>kwds<span class="classifier">keyword arguments</span></dt><dd><p>Arguments passed to the specific methods chosen.</p>
<dl class="field-list simple">
<dt class="field-odd">daofind</dt>
<dd class="field-odd"><p>See <code class="docutils literal notranslate"><span class="pre">astropy.stats.sigma_clipped_stats()</span></code> and <code class="docutils literal notranslate"><span class="pre">photutils.detection.DAOStarFinder()</span></code>.</p>
</dd>
</dl>
<dl class="simple">
<dt>sigma<span class="classifier">float | 5.0</span></dt><dd><p>Standard deviation of the clipping Gaussian.</p>
</dd>
<dt>fwhm<span class="classifier">float | 3.0</span></dt><dd><p>FWHM of the convoluting Gaussian kernel.</p>
</dd>
<dt>threshfactor<span class="classifier">float | 8</span></dt><dd><p>Intensity threshold for background-foreground separation (foreground is above threshold).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">maxlist</dt>
<dd class="field-odd"><p>See <code class="docutils literal notranslate"><span class="pre">skimage.feature.peak_local_max()</span></code>.</p>
</dd>
</dl>
<dl class="simple">
<dt>mindist<span class="classifier">float | 10</span></dt><dd><p>Minimal distance between two local maxima.</p>
</dd>
<dt>numpeaks<span class="classifier">int | 7</span></dt><dd><p>Maximum number of detected peaks.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-even">Return</dt>
<dd class="field-even"><dl class="simple">
<dt>pks<span class="classifier">2D array</span></dt><dd><p>Pixel coordinates of detected peaks, in (column, row) ordering.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.peaksearch">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">peaksearch</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">traces</span></em>, <em class="sig-param"><span class="n">tof</span></em>, <em class="sig-param"><span class="n">ranges</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'range-limited'</span></em>, <em class="sig-param"><span class="n">pkwindow</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.peaksearch" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect a list of peaks in the corresponding regions of multiple EDCs</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>traces<span class="classifier">2D array</span></dt><dd><p>Collection of EDCs.</p>
</dd>
<dt>tof<span class="classifier">1D array</span></dt><dd><p>Time-of-flight values.</p>
</dd>
<dt>ranges<span class="classifier">list of tuples/lists | None</span></dt><dd><p>List of ranges for peak detection in the format
[(LowerBound1, UpperBound1), (LowerBound2, UpperBound2), ….].</p>
</dd>
<dt>method<span class="classifier">str | ‘range-limited’</span></dt><dd><p>Method for peak-finding (‘range-limited’ and ‘alignment’).</p>
</dd>
<dt>pkwindow<span class="classifier">int | 3</span></dt><dd><p>Window width of a peak(amounts to lookahead in <code class="docutils literal notranslate"><span class="pre">mpes.analysis.peakdetect1d</span></code>).</p>
</dd>
<dt>plot<span class="classifier">bool | False</span></dt><dd><p>Specify whether to display a custom plot of the peak search results.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>pkmaxs<span class="classifier">1D array</span></dt><dd><p>Collection of peak positions</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.perspectiveWarping">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">perspectiveWarping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">img</span></em>, <em class="sig-param"><span class="n">landmarks</span></em>, <em class="sig-param"><span class="n">targs</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">'image'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.perspectiveWarping" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform image warping based on a generic affine transform (homography).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>img<span class="classifier">2D array</span></dt><dd><p>Input image (distorted).</p>
</dd>
<dt>landmarks<span class="classifier">list/array</span></dt><dd><p>List of pixel positions of the reference points.</p>
</dd>
<dt>targs<span class="classifier">list/array</span></dt><dd><p>List of pixel positions of the target points.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>imgaw<span class="classifier">2D array</span></dt><dd><p>Image after affine warping.</p>
</dd>
<dt>maw<span class="classifier">2D array</span></dt><dd><p>Homography matrix for the tranform.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.points2path">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">points2path</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pointsr</span></em>, <em class="sig-param"><span class="n">pointsc</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'analog'</span></em>, <em class="sig-param"><span class="n">npoints</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">'separated'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.points2path" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate ordered pixel cooridnates along a path defined by specific intermediate points.
The approach constructs the path using a set of line segments bridging the specified points,
therefore it is also able to trace the sequence indices of these special points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>pointsr, pointsc<span class="classifier">list/tuple/array</span></dt><dd><p>The row and column pixel coordinates of the special points along the sampling path.</p>
</dd>
<dt>method<span class="classifier">str | ‘analog’</span></dt><dd><p>Method of sampling.</p>
</dd>
<dt>npoints<span class="classifier">list/tuple | None</span></dt><dd><p>Number of points along each segment.</p>
</dd>
<dt>ret<span class="classifier">str | ‘separated’</span></dt><dd><p>Specify if return combined (‘combined’) or separated (‘separated’) row and column coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>polyr, polyc<span class="classifier">1D array</span></dt><dd><p>Pixel coordinates along the path traced out sequentially.</p>
</dd>
<dt>pid<span class="classifier">1D array</span></dt><dd><p>Pointwise indices of the special lpoints.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.rangeConvert">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">rangeConvert</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">xrng</span></em>, <em class="sig-param"><span class="n">pathcorr</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.rangeConvert" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert value range using a pairwise path correspondence (e.g. obtained
from time warping techniques).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>x<span class="classifier">1D array</span></dt><dd><p>Values of the x axis (e.g. time-of-flight values).</p>
</dd>
<dt>xrng<span class="classifier">list/tuple</span></dt><dd><p>Boundary value range on the x axis.</p>
</dd>
<dt>pathcorr<span class="classifier">list/tuple</span></dt><dd><p>Path correspondence between two 1D arrays in the following form,
[(id_1_trace_1, id_1_trace_2), (id_2_trace_1, id_2_trace_2), …]</p>
</dd>
</dl>
</dd>
<dt class="field-even">Return</dt>
<dd class="field-even"><dl class="simple">
<dt>xrange_trans<span class="classifier">tuple</span></dt><dd><p>Transformed range according to the path correspondence.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.rectmask">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">rectmask</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">img</span></em>, <em class="sig-param"><span class="n">rcent</span></em>, <em class="sig-param"><span class="n">ccent</span></em>, <em class="sig-param"><span class="n">shift</span></em>, <em class="sig-param"><span class="n">direction</span><span class="o">=</span><span class="default_value">'row'</span></em>, <em class="sig-param"><span class="n">sign</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">'mask'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.rectmask" title="Permalink to this definition">¶</a></dt>
<dd><p>Use a rectangular binary mask to cover an image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>img<span class="classifier">2D array</span></dt><dd><p>Input image to be masked</p>
</dd>
<dt>rcent<span class="classifier">float</span></dt><dd><p>Row center position</p>
</dd>
<dt>ccent<span class="classifier">float</span></dt><dd><p>Column center position</p>
</dd>
<dt>shift<span class="classifier">int/list of int</span></dt><dd><p>Pixel shifts</p>
</dd>
<dt>direction<span class="classifier">str | ‘row’</span></dt><dd><p>Direction to apply the shift to, ‘row’ or ‘column’ indicates row-wise
or column-wise shift for generating the rectangular mask</p>
</dd>
<dt>sign<span class="classifier">int/str | 1</span></dt><dd><p>Value of the masked region (0, 1, ‘nan’ or ‘xnan’).
‘xnan’ means the masked region is 1 and the other region nan.</p>
</dd>
<dt>ret<span class="classifier">str | ‘mask’</span></dt><dd><p>Return type (‘mask’, ‘masked_image’)</p>
</dd>
</dl>
<p><a href="#id51"><span class="problematic" id="id52">**</span></a>kwds : keyword arguments</p>
</dd>
<dt class="field-even">Return</dt>
<dd class="field-even"><dl class="simple">
<dt>cmask or cmask*img<span class="classifier">2D array</span></dt><dd><p>Mask only or masked image</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.regionExpand">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">regionExpand</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mask</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.regionExpand" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand the region of a binarized image around a line position</p>
<p><strong>Parameters</strong>
mask : numeric binarized 2D array</p>
<blockquote>
<div><p>the mask to be expanded</p>
</div></blockquote>
<dl>
<dt><a href="#id53"><span class="problematic" id="id54">**</span></a>kwds<span class="classifier">keyword arguments</span></dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 21%" />
<col style="width: 16%" />
<col style="width: 62%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>keyword</p></th>
<th class="head"><p>data type</p></th>
<th class="head"><p>meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>method</p></td>
<td><p>str</p></td>
<td><p>method of choice (‘offset’, ‘growth’)</p></td>
</tr>
<tr class="row-odd"><td><p>value</p></td>
<td><p>numeric</p></td>
<td><p>value to be assigned to the masked</p></td>
</tr>
<tr class="row-even"><td><p>linecoords</p></td>
<td><p>2D array</p></td>
<td><p>contains x and y positions of the line</p></td>
</tr>
<tr class="row-odd"><td><p>axoffsets</p></td>
<td><p>tuple/list</p></td>
<td><p>[downshift upshift] pixel number</p></td>
</tr>
<tr class="row-even"><td><p>clipbounds</p></td>
<td><p>tuple/list</p></td>
<td><p>bounds in the clipping direction</p></td>
</tr>
<tr class="row-odd"><td><p>selem</p></td>
<td><p>ndarray</p></td>
<td><p>structuring element</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>
<p><strong>Return</strong>
mask : numeric 2D array</p>
<blockquote>
<div><p>modified mask (returns the original mask if insufficient arguments
are provided for the chosen method for region expansion)</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.ridgeDetect">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">ridgeDetect</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mask</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'mask_mean_y'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.ridgeDetect" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect the band ridges using selected methods.</p>
<p><strong>Parameters</strong></p>
<dl>
<dt>mask<span class="classifier">numeric 2D array</span></dt><dd><p>the 2D integer-valued mask with labeled bands</p>
</dd>
<dt>method<span class="classifier">str</span></dt><dd><p>the method used for ridge detection
‘mask_mean_y’ : mean mask position along y direction (default)
‘mask_mean_x’ : mean mask position along x direction</p>
</dd>
<dt><a href="#id55"><span class="problematic" id="id56">**</span></a>kwds<span class="classifier">keyword arguments</span></dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 26%" />
<col style="width: 54%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>keyword</p></th>
<th class="head"><p>data type</p></th>
<th class="head"><p>meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>x</p></td>
<td><p>int/float</p></td>
<td><p>x axis coordinates</p></td>
</tr>
<tr class="row-odd"><td><p>y</p></td>
<td><p>int/float</p></td>
<td><p>y axis coordinates</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>ridges<span class="classifier">list of dataframes</span></dt><dd><p>the ridge coordinates</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.segment2d">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">segment2d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">img</span></em>, <em class="sig-param"><span class="n">nbands</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.segment2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Electronic band segmentation using local thresholding
and connected component labeling</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>img<span class="classifier">2D numeric array</span></dt><dd><p>the 2D matrix to segment</p>
</dd>
<dt>nbands<span class="classifier">int</span></dt><dd><p>number of electronic bands</p>
</dd>
</dl>
<p><a href="#id57"><span class="problematic" id="id58">**</span></a>kwds : keyword arguments</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>imglabeled<span class="classifier">2D numeric array</span></dt><dd><p>labeled mask</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.shirley">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">shirley</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">maxiter</span><span class="o">=</span><span class="default_value">20</span></em>, <em class="sig-param"><span class="n">explicit</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">warning</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.shirley" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the 1D best Shirley-Proctor-Sherwood background S for a dataset (x, y).
A. Proctor, P. M. A. Sherwood, Anal. Chem. 54 13 (1982).
The function is adapted from Kane O’Donnell’s routine
1. Finds the biggest peak
2. Use the minimum value on either side of this peak as the terminal points
of the Shirley background.
3. Iterate over the process within maximum allowed iteration (maxiter) to
reach the tolerance level (tol).</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>x: 1D numeric array</dt><dd><p>The photoelectron energy axis.</p>
</dd>
<dt>y: 1D numeric array</dt><dd><p>The photoemission intensity axis.</p>
</dd>
<dt>tol: float | 1e-5</dt><dd><p>The fitting tolerance.</p>
</dd>
<dt>maxiter: int | 20</dt><dd><p>The maximal iteration.</p>
</dd>
<dt>explicit: bool | False</dt><dd><p>Option for explicit display of iteration number.</p>
</dd>
<dt>warning: bool | False</dt><dd><p>Option to display of warnings during calculation.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>sbg: 1D numeric array</dt><dd><p>Calculated Shirley background.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.shirley2d">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">shirley2d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">maxiter</span><span class="o">=</span><span class="default_value">20</span></em>, <em class="sig-param"><span class="n">explicit</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">warning</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.shirley2d" title="Permalink to this definition">¶</a></dt>
<dd><p>2D Shirley background removal</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>x: 1D numeric array</dt><dd><p>Photoemission energy axis.</p>
</dd>
<dt>y: 2D numeric array</dt><dd><p>Photoemission intensity matrix.</p>
</dd>
<dt>tol: float | 1e-5</dt><dd><p>The fitting tolerance.</p>
</dd>
<dt>maxiter: int | 20</dt><dd><p>The maximal iteration.</p>
</dd>
<dt>explicit: bool | False</dt><dd><p>Option for explicit display of iteration number.</p>
</dd>
<dt>warning: bool | False</dt><dd><p>Option to display of warnings during calculation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.vertexGenerator">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">vertexGenerator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">center</span></em>, <em class="sig-param"><span class="n">fixedvertex</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">cvd</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">arot</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">nside</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">direction</span><span class="o">=</span><span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">scale</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">diagdir</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">'all'</span></em>, <em class="sig-param"><span class="n">rettype</span><span class="o">=</span><span class="default_value">'float32'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.vertexGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Generation of the vertices of symmetric polygons.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt>center<span class="classifier">(int, int)</span></dt><dd><p>Pixel positions of the symmetry center (row pixel, column pixel).</p>
</dd>
<dt>fixedvertex<span class="classifier">(int, int) | None</span></dt><dd><p>Pixel position of the fixed vertex (row pixel, column pixel).</p>
</dd>
<dt>cvd<span class="classifier">numeric | None</span></dt><dd><p>Center-vertex distance.</p>
</dd>
<dt>arot<span class="classifier">float | None</span></dt><dd><p>Spacing in angle of rotation.</p>
</dd>
<dt>nside<span class="classifier">int | None</span></dt><dd><p>The total number of sides for the polygon.</p>
</dd>
<dt>direction<span class="classifier">int | -1</span></dt><dd><p>Direction of angular rotation (1 = counterclockwise, -1 = clockwise)</p>
</dd>
<dt>scale<span class="classifier">float | 1</span></dt><dd><p>Radial scaling factor.</p>
</dd>
<dt>diagdir<span class="classifier">str | None</span></dt><dd><p>Diagonal direction of the polygon (‘x’ or ‘y’).</p>
</dd>
<dt>ret<span class="classifier">str | ‘all’</span></dt><dd><p>Return type. Specify ‘all’ returns all vertices, specify ‘generated’
returns only the generated ones (without the fixedvertex in the argument).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Return</dt>
<dd class="field-even"><dl class="simple">
<dt>vertices<span class="classifier">2D array</span></dt><dd><p>Collection of generated vertices.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.voigt">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">voigt</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">feval</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">vardict</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.voigt" title="Permalink to this definition">¶</a></dt>
<dd><p>1D Voigt lineshape model. Returns numerical values if <code class="docutils literal notranslate"><span class="pre">feval=True</span></code>.</p>
<p><strong>Parameters</strong></p>
<dl>
<dt>feval: bool | False</dt><dd><p>Option to evaluate function.</p>
</dd>
<dt>vardict: dict | None</dt><dd><p>Dictionary containing values for the variables named as follows (as dictionary keys).</p>
<p><code class="docutils literal notranslate"><span class="pre">amp</span></code> function amplitude or scaling factor.</p>
<p><code class="docutils literal notranslate"><span class="pre">xvar</span></code> x values (energy values in a lineshape).</p>
<p><code class="docutils literal notranslate"><span class="pre">ctr</span></code> center position.</p>
<p><code class="docutils literal notranslate"><span class="pre">sig</span></code> standard deviation of the Gaussian component.</p>
<p><code class="docutils literal notranslate"><span class="pre">gam</span></code> linewidth of the Lorentzian component.</p>
</dd>
</dl>
</dd></dl>

</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="bandstructure.html" class="btn btn-neutral float-right" title="Band-mapping data classes (mpes.bandstructure)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="file_io.html" class="btn btn-neutral" title="File I/O &amp; Processing (mpes.fprocessing)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017-2020, R. Patrick Xian, Laurenz Rettig.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.1.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="_static/language_data.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>
var darknet=darknet||{},base=base||require("./base"),long=long||{Long:require("long")};darknet.ModelFactory=class{match(t){const e=t.identifier.split(".").pop().toLowerCase();if("cfg"==e||"model"==e){const e=t.text;if(-1!==e.substring(0,Math.min(e.length,1024)).indexOf("[net]"))return!0}return!1}open(t,e){return darknet.Metadata.open(e).then(e=>{const s=t.identifier,n=s.split(".");n.pop();const o=n.join(".");return t.request(o+".weights",null).then(n=>this._openModel(e,s,t.text,n)).catch(()=>this._openModel(e,s,t.text,null))})}_openModel(t,e,s,n){try{return new darknet.Model(t,s,n?new darknet.Weights(n):null)}catch(t){const s=t&&t.message?t.message:t.toString();throw new darknet.Error(s.replace(/\.$/,"")+" in '"+e+"'.")}}},darknet.Model=class{constructor(t,e,s){this._graphs=[],this._graphs.push(new darknet.Graph(t,e,s))}get format(){return"Darknet"}get graphs(){return this._graphs}},darknet.Graph=class{constructor(t,e,s){this._inputs=[],this._outputs=[],this._nodes=[];const n=[];let o=null;const u=e.split("\n");let a=0;for(;u.length>0;){a++;const t=u.shift(),e=t.replace(/\s/g,"");if(e.length>0)switch(e[0]){case"#":case";":break;case"[":o={},o.line=a,o.type="]"===e[e.length-1]?e.substring(1,e.length-1):e.substring(1),o.options={},n.push(o);break;default:if(!o||e[0]<32||e[0]>126)throw new darknet.Error("Invalid cfg '"+t.replace(/[^\x20-\x7E]+/g,"").trim()+"' at line "+a.toString()+".");if(o){const s=e.indexOf("=");if(s<0)throw new darknet.Error("Invalid cfg '"+t.replace(/[^\x20-\x7E]+/g,"").trim()+"' at line "+a.toString()+".");const n=e.substring(0,s),u=e.substring(s+1);o.options[n]=u}}}const option_find_int=(t,e,s)=>{let n=t[e];if("string"==typeof n&&n.startsWith("$")){const t=n.substring(1);n=i.has(t)?i.get(t):n}if(void 0!==n){const s=parseInt(n,10);if(!Number.isInteger(s))throw new darknet.Error("Invalid int option '"+JSON.stringify(t[e])+"'.");return s}return s},option_find_str=(t,e,s)=>{const n=t[e];return void 0!==n?n:s},make_shape=(t,e)=>{if(t.some(t=>0===t||void 0===t||isNaN(t)))throw new darknet.Error("Invalid tensor shape '"+JSON.stringify(t)+"' in '"+e+"'.");return new darknet.TensorShape(t)},load_weights=(t,e,n)=>{const o=s?s.bytes(4*e.reduce((t,e)=>t*e)):null,u=new darknet.TensorType("float32",make_shape(e,"load_weights")),a=new darknet.Tensor(u,o),r=new darknet.Argument("",null,a);return new darknet.Parameter(t,!1!==n,[r])},load_batch_normalize_weights=(t,e,s)=>{t.weights.push(load_weights(e+"scale",[s],""===e)),t.weights.push(load_weights(e+"mean",[s],""===e)),t.weights.push(load_weights(e+"variance",[s],""===e))},make_convolutional_layer=(t,e,s,n,o,u,a,r,i,h,l,p)=>{t.out_w=Math.floor((s+2*l-r)/i)+1,t.out_h=Math.floor((n+2*l-r)/h)+1,t.out_c=u,t.out=t.out_w*t.out_h*t.out_c,t.weights.push(load_weights(e+"biases",[u],""===e)),p&&load_batch_normalize_weights(t,e,u),t.weights.push(load_weights(e+"weights",[Math.floor(o/a),u,r,r],""===e)),t.outputs[0].type=new darknet.TensorType("float32",make_shape([t.out_w,t.out_h,t.out_c],"make_convolutional_layer"))},make_connected_layer=(t,e,s,n,o)=>{t.out_h=1,t.out_w=1,t.out_c=n,t.out=n,t.weights.push(load_weights(e+"biases",[n],""===e)),o&&load_batch_normalize_weights(t,e,n),t.weights.push(load_weights(e+"weights",[s,n],""===e)),t.outputs[0].type=new darknet.TensorType("float32",make_shape([n],"make_connected_layer"))},r={},i=new Map,h=n.shift();switch(h.type){case"net":case"network":r.h=option_find_int(h.options,"height",0),r.w=option_find_int(h.options,"width",0),r.c=option_find_int(h.options,"channels",0),r.inputs=option_find_int(h.options,"inputs",r.h*r.w*r.c);for(const t of Object.keys(h.options))i.set(t,h.options[t])}const l=r.w&&r.h&&r.c?new darknet.TensorType("float32",make_shape([r.w,r.h,r.c],"params-if")):new darknet.TensorType("float32",make_shape([r.inputs],"params-else"));if(r.arguments=[new darknet.Argument("input",l,null)],this._inputs.push(new darknet.Parameter("input",!0,r.arguments)),0===n.length)throw new darknet.Error("Config file has no sections.");let p=!0;for(let t=0;t<n.length;t++){const e=n[t];e.name=t.toString(),e.chain=[],e.layer={};const o=e.options,u=e.layer;switch(u.inputs=[].concat(r.arguments),u.outputs=[new darknet.Argument(t.toString(),null,null)],u.weights=[],e.type){case"shortcut":{const e=o.from?o.from.split(",").map(t=>Number.parseInt(t.trim(),10)):[];for(let s of e){s=s<0?t+s:s;const e=n[s].layer;e&&u.inputs.push(e.outputs[0])}delete o.from;break}case"sam":case"scale_channels":{let e=option_find_int(o,"from",0);e=e<0?t+e:e;const s=n[e].layer;s&&u.inputs.push(s.outputs[0]),delete o.from;break}case"route":{u.inputs=[],u.layers=[];const e=o.layers?o.layers.split(",").map(t=>Number.parseInt(t.trim(),10)):[];for(let s=0;s<e.length;s++){const o=n[e[s]<0?t+e[s]:e[s]].layer;o&&(u.inputs.push(o.outputs[0]),u.layers.push(o))}delete o.layers;break}}if(p){switch(e.type){case"conv":case"convolutional":case"deconvolutional":{const t=u.inputs[0].type.shape.dimensions;if(t[0]!==r.w||t[1]!==r.h||t[2]!==r.c)throw new darknet.Error("Layer before convolutional layer must output image.");const s=option_find_int(o,"size",1),n=option_find_int(o,"filters",1),a=option_find_int(o,"pad",0)?s>>1:option_find_int(o,"padding",0);let i=option_find_int(o,"stride_x",-1),h=option_find_int(o,"stride_y",-1);if(i<1||h<1){const t=option_find_int(o,"stride",1);i=i<1?t:i,h=h<1?t:h}const l=option_find_int(o,"groups",1),p=option_find_int(o,"batch_normalize",0),c=option_find_str(o,"activation","logistic");make_convolutional_layer(u,"",r.w,r.h,r.c,n,l,s,i,h,a,p),"logistic"!==c&&e.chain.push({type:c});break}case"connected":{const t=option_find_int(o,"output",1),s=option_find_int(o,"batch_normalize",0),n=option_find_str(o,"activation","logistic");make_connected_layer(u,"",r.inputs,t,s),"logistic"!==n&&e.chain.push({type:n});break}case"local":{const t=u.inputs[0].type.shape.dimensions;if(t[0]!==r.w||t[1]!==r.h||t[2]!==r.c)throw new darknet.Error("Layer before avgpool layer must output image.");const s=option_find_int(o,"filters",1),n=option_find_int(o,"size",1),a=option_find_int(o,"stride",1),i=option_find_int(o,"pad",0),h=option_find_str(o,"activation","logistic");u.out_h=Math.floor((r.h-(i?1:n))/a)+1,u.out_w=Math.floor((r.w-(i?1:n))/a)+1,u.out_c=s,u.out=u.out_w*u.out_h*u.out_c,u.weights.push(load_weights("weights",[r.c,s,n,n,u.out_h*u.out_w])),u.weights.push(load_weights("biases",[u.out_w*u.out_h*u.out_c])),u.outputs[0].type=new darknet.TensorType("float32",make_shape([u.out_w,u.out_h,u.out_c],"local")),"logistic"!==h&&e.chain.push({type:h});break}case"batchnorm":u.out_h=r.h,u.out_w=r.w,u.out_c=r.c,u.out=u.in,load_batch_normalize_weights(s,e,"",u.out),u.outputs[0].type=new darknet.TensorType("float32",make_shape([u.ouputs],"batchnorm"));break;case"activation":u.out_h=r.h,u.out_w=r.w,u.out_c=r.c,u.out=u.in,u.outputs[0].type=new darknet.TensorType("float32",make_shape([u.ouputs],"activation"));break;case"max":case"maxpool":{const t=u.inputs[0].type.shape.dimensions;if(t[0]!==r.w||t[1]!==r.h||t[2]!==r.c)throw new darknet.Error("Layer before maxpool layer must output image.");const e=option_find_int(o,"antialiasing",0),s=option_find_int(o,"stride",1),n=option_find_int(o,"stride_x",s),a=option_find_int(o,"stride_y",s),i=e?1:n,h=e?1:a,l=option_find_int(o,"size",s),p=option_find_int(o,"padding",l-1),c=option_find_int(o,"out_channels",1);if(option_find_int(o,"maxpool_depth",0)?(u.out_c=c,u.out_w=r.w,u.out_h=r.h):(u.out_w=Math.floor((r.w+p-l)/i)+1,u.out_h=Math.floor((r.h+p-l)/h)+1,u.out_c=r.c),e){const t=2===e?2:3,s=2===e?0:Math.floor(t/3);u.input_layer={weights:[],outputs:u.outputs},make_convolutional_layer(u.input_layer,"",u.out_h,u.out_w,u.out_c,u.out_c,u.out_c,t,n,a,s,0),u.out_w=u.input_layer.out_w,u.out_h=u.input_layer.out_h,u.out_c=u.input_layer.out_c}else u.outputs[0].type=new darknet.TensorType("float32",make_shape([u.out_w,u.out_h,u.out_c],"maxpool"));u.out=u.out_w*u.out_h*u.out_c;break}case"avgpool":{const t=u.inputs[0].type.shape.dimensions;if(t[0]!==r.w||t[1]!==r.h||t[2]!==r.c)throw new darknet.Error("Layer before avgpool layer must output image.");u.out_w=1,u.out_h=1,u.out_c=r.c,u.out=u.out_c,u.outputs[0].type=new darknet.TensorType("float32",make_shape([u.out_w,u.out_h,u.out_c],"avgpool"));break}case"crnn":{const t=option_find_int(o,"size",3),e=option_find_int(o,"stride",1),s=option_find_int(o,"output",1),n=option_find_int(o,"hidden",1),a=option_find_int(o,"groups",1),i=option_find_int(o,"pad",0)?t>>1:option_find_int(o,"padding",0),h=option_find_int(o,"batch_normalize",0);u.input_layer={weights:[],outputs:[new darknet.Argument("",null,null)]},make_convolutional_layer(u.input_layer,"input_",r.h,r.w,r.c,n,a,t,e,e,i,h),u.self_layer={weights:[],outputs:[new darknet.Argument("",null,null)]},make_convolutional_layer(u.self_layer,"self_",r.h,r.w,n,n,a,t,e,e,i,h),u.output_layer={weights:[],outputs:u.outputs},make_convolutional_layer(u.output_layer,"output_",r.h,r.w,n,s,a,t,e,e,i,h),u.weights=u.weights.concat(u.input_layer.weights),u.weights=u.weights.concat(u.self_layer.weights),u.weights=u.weights.concat(u.output_layer.weights),u.out_h=u.output_layer.out_h,u.out_w=u.output_layer.out_w,u.out_c=s,u.out=u.output_layer.out;break}case"rnn":{const t=option_find_int(o,"output",1),e=option_find_int(o,"hidden",1),s=option_find_int(o,"batch_normalize",0),n=r.inputs;u.input_layer={weights:[],outputs:[new darknet.Argument("",null,null)]},make_connected_layer(u.input_layer,"input_",n,e,s),u.self_layer={weights:[],outputs:[new darknet.Argument("",null,null)]},make_connected_layer(u.self_layer,"self_",e,e,s),u.output_layer={weights:[],outputs:u.outputs},make_connected_layer(u.output_layer,"output_",e,t,s),u.weights=u.weights.concat(u.input_layer.weights),u.weights=u.weights.concat(u.self_layer.weights),u.weights=u.weights.concat(u.output_layer.weights),u.out_w=1,u.out_h=1,u.out_c=t,u.out=t;break}case"gru":{const t=r.inputs,e=option_find_int(o,"output",1),s=option_find_int(o,"batch_normalize",0);u.input_z_layer={weights:[],outputs:[new darknet.Argument("",null,null)]},make_connected_layer(u.input_z_layer,"input_z",t,e,s),u.state_z_layer={weights:[],outputs:[new darknet.Argument("",null,null)]},make_connected_layer(u.state_z_layer,"state_z",e,e,s),u.input_r_layer={weights:[],outputs:[new darknet.Argument("",null,null)]},make_connected_layer(u.input_r_layer,"input_r",t,e,s),u.state_r_layer={weights:[],outputs:[new darknet.Argument("",null,null)]},make_connected_layer(u.state_r_layer,"state_r",e,e,s),u.input_h_layer={weights:[],outputs:[new darknet.Argument("",null,null)]},make_connected_layer(u.input_h_layer,"input_h",t,e,s),u.state_h_layer={weights:[],outputs:[new darknet.Argument("",null,null)]},make_connected_layer(u.state_h_layer,"state_h",e,e,s),u.weights=u.weights.concat(u.input_z_layer.weights),u.weights=u.weights.concat(u.state_z_layer.weights),u.weights=u.weights.concat(u.input_r_layer.weights),u.weights=u.weights.concat(u.state_r_layer.weights),u.weights=u.weights.concat(u.input_h_layer.weights),u.weights=u.weights.concat(u.state_h_layer.weights),u.out=e,u.outputs[0].type=new darknet.TensorType("float32",make_shape([e],"gru"));break}case"lstm":{const t=r.inputs,e=option_find_int(o,"output",1),n=option_find_int(o,"batch_normalize",0);u.uf={weights:[],outputs:[new darknet.Argument("",null,null)]},make_connected_layer(u.uf,"uf_",t,e,n),u.ui={weights:[],outputs:[new darknet.Argument("",null,null)]},make_connected_layer(u.ui,"ui_",t,e,n),u.ug={weights:[],outputs:[new darknet.Argument("",null,null)]},make_connected_layer(u.ug,"ug_",t,e,n),u.uo={weights:[],outputs:[new darknet.Argument("",null,null)]},make_connected_layer(u.uo,"uo_",t,e,n),u.wf={weights:[],outputs:[new darknet.Argument("",null,null)]},make_connected_layer(u.wf,"wf_",e,e,n),u.wi={weights:[],outputs:[new darknet.Argument("",null,null)]},make_connected_layer(u.wi,"wi_",e,e,n),u.wg={weights:[],outputs:[new darknet.Argument("",null,null)]},make_connected_layer(u.wg,"wg_",e,e,n),u.wo={weights:[],outputs:[new darknet.Argument("",null,null)]},make_connected_layer(u.wo,"wo_",e,e,n),u.weights=u.weights.concat(u.uf.weights),u.weights=u.weights.concat(u.ui.weights),u.weights=u.weights.concat(u.ug.weights),u.weights=u.weights.concat(u.uo.weights),u.weights=u.weights.concat(u.wf.weights),u.weights=u.weights.concat(u.wi.weights),u.weights=u.weights.concat(u.wg.weights),u.weights=u.weights.concat(u.wo.weights),u.out_w=1,u.out_h=1,u.out_c=e,u.out=e,u.outputs[0].type=new darknet.TensorType("float32",make_shape([e],"lstm")),s=null;break}case"softmax":u.out_w=r.w,u.out_h=r.h,u.out_c=r.c,u.out=r.inputs,u.outputs[0].type=new darknet.TensorType("float32",make_shape([u.out],"softmax"));break;case"dropout":u.out_w=r.w,u.out_h=r.h,u.out_c=r.c,u.out=r.inputs,u.outputs[0].type=new darknet.TensorType("float32",make_shape([u.out_w,u.out_h,u.out_c],"dropout"));break;case"upsample":{const t=option_find_int(o,"stride",2);u.out_w=r.w*t,u.out_h=r.h*t,u.out_c=r.c,u.out=u.out_w*u.out_h*u.out_c,u.outputs[0].type=new darknet.TensorType("float32",make_shape([u.out_w,u.out_h,u.out_c],"upsample"));break}case"crop":{const t=u.inputs[0].type.shape.dimensions;if(t[0]!==r.w||t[1]!==r.h||t[2]!==r.c)throw new darknet.Error("Layer before crop layer must output image.");const e=option_find_int(o,"crop_height",1),s=option_find_int(o,"crop_width",1);u.out_w=s,u.out_h=e,u.out_c=r.c,u.out=u.out_w*u.out_h*u.out_c,u.outputs[0].type=new darknet.TensorType("float32",make_shape([u.out_w,u.out_h,u.out_c],"crop"));break}case"yolo":{const t=option_find_int(o,"classes",20),e=option_find_int(o,"num",1);u.out_h=r.h,u.out_w=r.w,u.out_c=e*(t+4+1),u.out=u.out_h*u.out_w*u.out_c,u.outputs[0].type=new darknet.TensorType("float32",make_shape([u.out_w,u.out_h,u.out_c],"yolo"));break}case"Gaussian_yolo":{const t=option_find_int(o,"classes",20),e=option_find_int(o,"num",1);u.out_h=r.h,u.out_w=r.w,u.out_c=e*(t+8+1),u.out=u.out_h*u.out_w*u.out_c,u.outputs[0].type=new darknet.TensorType("float32",make_shape([u.out_w,u.out_h,u.out_c],"Gaussian_yolo"));break}case"region":{const t=option_find_int(o,"coords",4),e=option_find_int(o,"classes",20),s=option_find_int(o,"num",1);u.out=r.h*r.w*s*(e+t+1),u.outputs[0].type=new darknet.TensorType("float32",make_shape([r.h,r.w,s,e+t+1],"region"));break}case"cost":u.out=r.inputs,u.outputs[0].type=new darknet.TensorType("float32",make_shape([u.out],"cost"));break;case"reorg":{const t=option_find_int(o,"stride",1),e=option_find_int(o,"reverse",0),s=option_find_int(o,"extra",0);e?(u.out_w=r.w*t,u.out_h=r.h*t,u.out_c=Math.floor(r.c/(t*t))):(u.out_w=Math.floor(r.w/t),u.out_h=Math.floor(r.h/t),u.out_c=r.c*(t*t)),u.out=u.out_h*u.out_w*u.out_c,s&&(u.out_w=0,u.out_h=0,u.out_c=0,u.out=r.h*r.w*r.c+s),u.outputs[0].type=new darknet.TensorType("float32",make_shape([u.out],"reorg"));break}case"route":{const t=[].concat(u.layers),e=option_find_int(o,"groups",1);u.out=0;for(const s of t)u.out+=s.outputs/e;if(t.length>0){const s=t.shift();for(u.out_w=s.out_w,u.out_h=s.out_h,u.out_c=s.out_c/e;t.length>0;){const e=t.shift();if(e.out_w!==s.out_w||e.out_h!==s.out_h){p=!1;break}u.out_c+=e.out_c}p&&(u.outputs[0].type=new darknet.TensorType("float32",make_shape([u.out_w,u.out_h,u.out_c],"route")))}else p=!1;p||(u.out_h=0,u.out_w=0,u.out_c=0);break}case"shortcut":case"scale_channels":case"sam":{const t=option_find_str(o,"activation","linear");u.out_w=r.w,u.out_h=r.h,u.out_c=r.c,u.out=r.w*r.h*r.c,u.outputs[0].type=new darknet.TensorType("float32",make_shape([r.w,r.h,r.c],"shortcut|scale_channels|sam")),"linear"!==t&&e.chain.push({type:t});break}case"detection":u.out_w=r.w,u.out_h=r.h,u.out_c=r.c,u.out=r.inputs,u.outputs[0].type=new darknet.TensorType("float32",make_shape([u.out],"detection"));break;default:p=!1}r.h=u.out_h,r.w=u.out_w,r.c=u.out_c,r.inputs=u.out,r.last=e}r.arguments=u.outputs}for(let e=0;e<n.length;e++)this._nodes.push(new darknet.Node(t,h,n[e]));s&&s.validate()}get inputs(){return this._inputs}get outputs(){return this._outputs}get nodes(){return this._nodes}},darknet.Parameter=class{constructor(t,e,s){this._name=t,this._visible=e,this._arguments=s}get name(){return this._name}get visible(){return this._visible}get arguments(){return this._arguments}},darknet.Argument=class{constructor(t,e,s){if("string"!=typeof t)throw new darknet.Error("Invalid argument identifier '"+JSON.stringify(t)+"'.");this._name=t,this._type=e,this._initializer=s}get name(){return this._name}get type(){return this._initializer?this._initializer.type:this._type}set type(t){if(this._type)throw new darknet.Error("Invalid argument type set operation.");this._type=t}get initializer(){return this._initializer}},darknet.Node=class{constructor(t,e,s){this._name=s.name||"",this._location=void 0!==s.line?s.line.toString():void 0,this._metadata=t,this._type=s.type,this._attributes=[],this._inputs=[],this._outputs=[],this._chain=[];const n=s.layer;if(n&&n.inputs&&n.inputs.length>0&&this._inputs.push(new darknet.Parameter(n.inputs.length<=1?"input":"inputs",!0,n.inputs)),n&&n.weights&&n.weights.length>0&&(this._inputs=this._inputs.concat(n.weights)),n&&n.outputs&&n.outputs.length>0&&this._outputs.push(new darknet.Parameter(n.outputs.length<=1?"output":"outputs",!0,n.outputs)),s.chain)for(const n of s.chain)this._chain.push(new darknet.Node(t,e,n,""));const o=s.options;if(o)for(const e of Object.keys(o))this._attributes.push(new darknet.Attribute(t.attribute(this._type,e),e,o[e]))}get name(){return this._name}get location(){return this._location}get type(){return this._type}get metadata(){return this._metadata.type(this._type)}get attributes(){return this._attributes}get inputs(){return this._inputs}get outputs(){return this._outputs}get chain(){return this._chain}},darknet.Attribute=class{constructor(t,e,s){if(this._name=e,this._value=s,t){switch(this._type=t.type||"",this._type){case"int32":{const t=parseInt(this._value,10);Number.isInteger(t)&&(this._value=t);break}case"float32":{const t=parseFloat(this._value);isNaN(t)||(this._value=t);break}case"int32[]":{const t=this._value.split(",").map(t=>parseInt(t.trim(),10));t.every(t=>Number.isInteger(t))&&(this._value=t);break}}(Object.prototype.hasOwnProperty.call(t,"visible")&&!t.visible||Object.prototype.hasOwnProperty.call(t,"default")&&this._value==t.default)&&(this._visible=!1)}}get name(){return this._name}get type(){return this._type}get value(){return this._value}get visible(){return 0!=this._visible}},darknet.Tensor=class{constructor(t,e){this._type=t,this._data=e}get kind(){return"Tensor"}get name(){return""}get type(){return this._type}get state(){return this._context().state}get value(){const t=this._context();return t.state?null:(t.limit=Number.MAX_SAFE_INTEGER,this._decode(t,0))}toString(){const t=this._context();if(t.state)return"";t.limit=1e4;const e=this._decode(t,0);return JSON.stringify(e,null,4)}_context(){const t={};return this._data?(t.state=null,t.position=0,t.count=0,t.dataView=new DataView(this._data.buffer,this._data.byteOffset,this._data.byteLength),t.dimensions=this.type.shape.dimensions,t):(t.state="Tensor data is empty.",t)}_decode(t,e){const s=[],n=t.dimensions[e];if(e==t.dimensions.length-1)for(let e=0;e<n;e++){if(t.count>t.limit)return s.push("..."),s;s.push(t.dataView.getFloat32(t.position,!0)),t.position+=4,t.count++}else for(let o=0;o<n;o++){if(t.count>t.limit)return s.push("..."),s;s.push(this._decode(t,e+1))}return s}},darknet.TensorType=class{constructor(t,e){this._dataType=t,this._shape=e}get dataType(){return this._dataType}get shape(){return this._shape}toString(){return(this._dataType||"?")+this._shape.toString()}},darknet.TensorShape=class{constructor(t){if(t.some(t=>0===t||void 0===t||isNaN(t)))throw new darknet.Error("Invalid tensor shape '"+JSON.stringify(t)+"'.");this._dimensions=t}get dimensions(){return this._dimensions}toString(){return this._dimensions?0==this._dimensions.length?"":"["+this._dimensions.map(t=>t.toString()).join(",")+"]":""}},darknet.Weights=class{constructor(t){this._buffer=t,this._dataView=new DataView(t.buffer,t.byteOffset,t.byteLength),this._position=0;const e=this.int32(),s=this.int32(),n=this.int32();this._seen=10*e+s>=2?this.int64():this.int32();if(e>1e3||s>1e3)throw new darknet.Error("Unsupported transpose weights file version '"+[e,s,n].join(".")+"'.")}int32(){const t=this._position;return this.skip(4),this._dataView.getInt32(t,!0)}int64(){const t=this.int32(),e=this.int32();return new long.Long(t,e,!0).toNumber()}bytes(t){const e=this._position;return this.skip(t),this._buffer.subarray(e,this._position)}skip(t){if(this._position+=t,this._position>this._buffer.length)throw new darknet.Error("Expected "+(this._position-this._buffer.length)+" more bytes. The file might be corrupted. Unexpected end of file.")}validate(){if(this._position!==this._buffer.length)throw new darknet.Error("Invalid weights size.")}},darknet.Metadata=class{static open(t){return darknet.Metadata._metadata?Promise.resolve(darknet.Metadata._metadata):t.request(null,"darknet-metadata.json","utf-8").then(t=>(darknet.Metadata._metadata=new darknet.Metadata(t),darknet.Metadata._metadata)).catch(()=>(darknet.Metadata._metadata=new darknet.Metadata(null),darknet.Metadata._metadata))}constructor(t){if(this._map=new Map,this._attributeMap=new Map,t){const e=JSON.parse(t);if(e)for(const t of e)if(t&&t.name&&t.schema){if(this._map.has(t.name))throw new darknet.Error("Duplicate metadata key '"+t.name+"'.");t.schema.name=t.name,this._map.set(t.name,t.schema)}}}type(t){return this._map.get(t)||null}attribute(t,e){const s=t+":"+e;if(!this._attributeMap.has(s)){this._attributeMap.set(s,null);const e=this.type(t);if(e&&e.attributes)for(const s of e.attributes)this._attributeMap.set(t+":"+s.name,s)}return this._attributeMap.get(s)}},darknet.Error=class extends Error{constructor(t){super(t),this.name="Error loading Darknet model."}},"undefined"!=typeof module&&"object"==typeof module.exports&&(module.exports.ModelFactory=darknet.ModelFactory);
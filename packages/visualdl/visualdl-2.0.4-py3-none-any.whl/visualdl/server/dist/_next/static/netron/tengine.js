var tengine=tengine||{},base=base||require("./base");tengine.ModelFactory=class{match(t){if("tmfile"===t.identifier.split(".").pop().toLowerCase()){const i=t.buffer;if(i.length>4){if((i[0]|i[1]<<8)<4)return!0}}return!1}open(t,i){return tengine.Metadata.open(i).then(i=>{const e=t.identifier.toLowerCase();try{const e=t.buffer,s=e[0]|e[1]<<8,n=e[2]|e[3]<<8;if(2!==s)throw new tengine.Error("Unsupported format version 'v"+s.toString()+"."+n.toString()+"'.");return new tengine.Model(i,e)}catch(t){const i=t&&t.message?t.message:t.toString();throw new tengine.Error(i.replace(/\.$/,"")+" in '"+e+"'.")}})}},tengine.Model=class{constructor(t,i){const e=new tengine.ModelFileReader(i);this._version=e.version,this._source=e.source,this._graphs=e.graphs.map(i=>new tengine.Graph(t,i))}get format(){return"Tengine v"+this._version}get source(){return this._source}get graphs(){return this._graphs}},tengine.Graph=class{constructor(t,i){this._name=i.id.toString(),this._inputs=[],this._outputs=[],this._nodes=[];const e=i.tensors.map(t=>new tengine.Argument(t));for(const t of i.inputs){const i=e[t];this._inputs.push(new tengine.Parameter(i.name,!0,[i]))}for(const t of i.outputs){const i=e[t];i.type&&i.type.shape&&i.type.shape.dimensions&&0==i.type.shape.dimensions.length&&null!==i.initializer||this._outputs.push(new tengine.Parameter(i.name,!0,[i]))}for(const s of i.nodes)"INPUT"!==s.type&&this._nodes.push(new tengine.Node(t,s,e))}get name(){return this._name}get inputs(){return this._inputs}get outputs(){return this._outputs}get nodes(){return this._nodes}},tengine.Parameter=class{constructor(t,i,e){this._name=t,this._visible=i,this._arguments=e}get name(){return this._name}get visible(){return this._visible}get arguments(){return this._arguments}},tengine.Argument=class{constructor(t){this._name=t.name,this._type=new tengine.TensorType(t.dataType,new tengine.TensorShape(t.dims)),this._initializer=2===t.type?new tengine.Tensor(this._type,t.buffer):null}get name(){return this._name}get type(){return this._initializer?this._initializer.type:this._type}get quantization(){return null}get initializer(){return this._initializer}},tengine.Node=class{constructor(t,i,e){this._metadata=t,this._name=i.name,this._type=i.type+(i.version&&1!==i.version?":"+i.version.toString():""),this._inputs=[],this._outputs=[],this._attributes=[];const s=t.type(this._type);for(let t=0;t<i.params.length;t++){const e=s&&s.attributes&&t<s.attributes.length?s.attributes[t]:null,n=e?e.name:t.toString();this._attributes.push(new tengine.Attribute(e,n,i.params[t]))}const n=i.inputs;let a=0;if(s&&s.inputs){for(const t of s.inputs)if(a<n.length||"optional"!=t.option){const i="variadic"==t.option?n.length-a:1,s=n.slice(a,a+i).filter(i=>""!=i||"optional"!=t.option).map(t=>e[t]);this._inputs.push(new tengine.Parameter(t.name,!0,s)),a+=i}}else this._inputs=this._inputs.concat(n.slice(a).map((t,i)=>{const s=a+i==0?"input":(a+i).toString();return new tengine.Parameter(s,!0,[e[t]])}));const r=i.outputs;let o=0;if(s&&s.outputs){for(const t of s.outputs)if(o<r.length||"optional"!=t.option){const i="variadic"==t.option?r.length-o:1,s=r.slice(o,o+i).map(t=>e[t]);this._outputs.push(new tengine.Parameter(t.name,!0,s)),o+=i}}else this._outputs=this._outputs.concat(r.slice(o).map((t,i)=>{const s=o+i==0?"output":(o+i).toString();return new tengine.Parameter(s,!0,[e[t]])}))}get type(){return this._type.split(":")[0]}get name(){return this._name}get metadata(){return this._metadata.type(this._type)}get attributes(){return this._attributes}get inputs(){return this._inputs}get outputs(){return this._outputs}},tengine.Attribute=class{constructor(t,i,e){this._type="",this._name=i,this._value=e,t&&(this._name=t.name,t.type&&(this._type=t.type),(Object.prototype.hasOwnProperty.call(t,"visible")&&!t.visible||Object.prototype.hasOwnProperty.call(t,"default")&&(this._value==t.default||this._value&&this._value.toString()==t.default.toString()))&&(this._visible=!1))}get type(){return this._type}get name(){return this._name}get value(){return this._value}get visible(){return 0!=this._visible}},tengine.Tensor=class{constructor(t,i,e){this._type=t,this._data=i,this._kind=e}get kind(){return this._kind}get type(){return this._type}get state(){return this._context().state||null}get value(){const t=this._context();return t.state?null:(t.limit=Number.MAX_SAFE_INTEGER,this._decode(t,0))}toString(){const t=this._context();if(t.state)return"";t.limit=1e4;const i=this._decode(t,0);return JSON.stringify(i,null,4)}_context(){const t={index:0,count:0,state:null};if("?"==this._type.dataType)return t.state="Tensor has unknown data type.",t;if(!this._type.shape||this._type.shape.dimensions&&0==this._type.shape.dimensions.length)return t.state="Tensor has no dimensions.",t;if(!this._data)return t.state="Tensor data is empty.",t;switch(this._type.dataType){case"int8":case"uint8":case"float16":case"float32":case"int32":case"int16":t.data=new DataView(this._data.buffer,this._data.byteOffset,this._data.byteLength);break;default:t.state="Tensor data type is not implemented."}return t.dataType=this._type.dataType,t.shape=this._type.shape.dimensions,t}_decode(t,i){const e=0==t.shape.length?[1]:t.shape,s=[],n=e[i];if(i==e.length-1)for(let i=0;i<n;i++){if(t.count>t.limit)return s.push("..."),s;switch(this._type.dataType){case"float32":s.push(t.data.getFloat32(t.index,!0)),t.index+=4,t.count++;break;case"float16":s.push(t.data.getFloat16(t.index,!0)),t.index+=2,t.count++;break;case"int8":s.push(t.data.getInt8(t.index,!0)),t.index+=1,t.count++;break;case"uint8":s.push(t.data.getUint8(t.index,!0)),t.index+=1,t.count++;break;case"int32":s.push(t.data.getInt32(t.index,!0)),t.index+=4,t.count++;break;case"int16":s.push(t.data.getInt16(t.index,!0)),t.index+=2,t.count++}}else for(let e=0;e<n;e++){if(t.count>t.limit)return s.push("..."),s;s.push(this._decode(t,i+1))}return 0==t.shape.length?s[0]:s}},tengine.TensorType=class{constructor(t,i){switch(t){case 0:this._dataType="float32";break;case 1:this._dataType="float16";break;case 2:this._dataType="int8";break;case 3:this._dataType="uint8";break;case 4:this._dataType="int32";break;case 5:this._dataType="int16";break;default:throw new tengine.Error("Unknown data type'"+t+"'.")}this._shape=i}get dataType(){return this._dataType}get shape(){return this._shape}toString(){return this._dataType+this._shape.toString()}},tengine.TensorShape=class{constructor(t){this._dimensions=t}get dimensions(){return this._dimensions}toString(){return this._dimensions?"["+this._dimensions.map(t=>t?t.toString():"?").join(",")+"]":""}},tengine.Metadata=class{static open(t){return tengine.Metadata._metadata?Promise.resolve(tengine.Metadata._metadata):t.request(null,"tengine-metadata.json","utf-8").then(t=>(tengine.Metadata._metadata=new tengine.Metadata(t),tengine.Metadata._metadata)).catch(()=>(tengine.Metadata._metadata=new tengine.Metadata(null),tengine.Metadata._metadata))}constructor(t){if(this._map={},this._attributeCache={},t){const i=JSON.parse(t);if(i)for(const t of i)if(t.name&&t.schema){t.schema.name=t.name;const i=t.name+(t.version&&1!==t.version?":"+t.version.toString():"");this._map[i]=t.schema}}}type(t){return this._map[t]||null}attribute(t,i){let e=this._attributeCache[t];if(!e){e={};const i=this.type(t);if(i&&i.attributes&&i.attributes.length>0)for(const t of i.attributes)e[t.name]=t;this._attributeCache[t]=e}return e[i]||null}},tengine.ModelFileReader=class{constructor(t){const i=new Map,register=(t,e,s,n)=>{i.set(t.toString()+":"+e.toString(),{name:s,params:n})};register(0,1,"Accuracy",[]),register(1,1,"BatchNormalization",["f","f","i"]),register(2,1,"BilinearResize",["f","f","i"]),register(3,1,"Concat",["i"]),register(4,1,"Const",[]),register(5,1,"Convolution",["i","i","i","i","i","i","i","i","i","i","i","i","i","i"]),register(6,1,"DeConvolution",["i","i","i","i","i","i","i","i","i","i","i","i","i"]),register(7,1,"DetectionOutput",["i","i","i","f","f"]),register(8,1,"DropOut",[]),register(9,1,"Eltwise",["i","i"]),register(10,1,"Flatten",["i"]),register(11,1,"FullyConnected",["i"]),register(12,1,"INPUT",[]),register(13,1,"LRN",["i","f","f","i","f"]),register(14,1,"Normalize",["i","i"]),register(15,1,"Permute",["i","i","i","i","i"]),register(16,1,"Pooling",["i","i","i","i","i","i","i","i","i","i","i"]),register(17,1,"Prelu",[]),register(18,1,"PriorBox",["f[]","f[]","f[]","f[]","i","i","i","i","i","f","f","f","i","i"]),register(19,1,"Region",["i","i","i","i","f","f","f[]"]),register(20,1,"ReLU",["f"]),register(21,1,"ReLU6",[]),register(22,1,"Reorg",["i"]),register(23,1,"Reshape",["i","i","i","i","i","i"]),register(23,2,"Reshape",["i","i","i[]"]),register(24,1,"RoiPooling",["i","i","f"]),register(25,1,"RPN",["f[]","f[]","i","i","i","i","i","f","anchors"]),register(26,1,"Scale",["i","i","i"]),register(27,1,"Slice",["i","i[]","i[]","i[]","i","i","i","i","i"]),register(28,1,"SoftMax",["i"]),register(29,1,"Split",["i","i","boolean","boolean","i[]"]),register(30,1,"DetectionPostProcess",["i","i","f","f","i","f[]"]),register(31,1,"Gemm",["f","f","i","i"]),register(32,1,"Generic",["i","i","string"]),register(33,1,"Logistic",[]),register(34,1,"LSTM",["f","f","i","i","i","i","i","i","i","i","i","i","i","i","i","i","i","i"]),register(35,1,"RNN",["f","i","i","i","i","i","i","i","i","i"]),register(36,1,"TanH",[]),register(37,1,"Sigmoid",[]),register(38,1,"Squeeze",["i","i","i","i"]),register(39,1,"FusedbnScaleRelu",[]),register(40,1,"Pad",["i","i","i","i","i","i","i","i","i","f"]),register(41,1,"StridedSlice",["i","i","i","i","i","i","i","i","i","i","i","i"]),register(42,1,"ArgMax",["i"]),register(43,1,"ArgMin",["i"]),register(44,1,"TopKV2",["i","i"]),register(45,1,"Reduction",["i","i","i","i","i","i"]),register(46,1,"Max",[]),register(47,1,"Min",[]),register(48,1,"GRU",["f","i","i","i","i","i","i","i","i","i"]),register(49,1,"Addn","i"),register(50,1,"SwapAxis",["i","i"]),register(51,1,"Upsample",["f"]),register(52,1,"SpaceToBatchND",["i","i","i","i","i","i"]),register(53,1,"BatchToSpaceND",["i","i","i","i","i","i"]),register(54,1,"Resize",["f","f","i"]),register(55,1,"ShuffleChannel",["i"]),register(56,1,"Crop",["i","i","i","i","i","i","boolean","i","i"]),register(57,1,"ROIAlign",["i","i","f"]),register(58,1,"Psroipooling",["i","i","f","i"]),register(59,1,"Unary",["i"]),register(60,1,"Expanddims",["i"]),register(61,1,"Bias",["i"]),register(62,1,"Noop",[]),register(63,1,"Threshold",["f"]),register(64,1,"Hardsigmoid",["f","f"]),register(65,1,"Embed",["f","f","f","f"]),register(66,1,"InstanceNorm",["f"]),register(67,1,"MVN",["i","i","f"]),register(68,1,"Absval",[]),register(69,1,"Cast",["i","i"]),register(70,1,"HardSwish",["f","f"]),register(71,1,"Interp",["i","i","f","f","i"]),register(72,1,"SELU",["f","f"]),register(73,1,"ELU",["f"]),register(74,1,"BroadMul",[]),register(75,1,"Logical",["i"]),register(76,1,"Gather",["i","i"]),register(77,1,"Transpose",["i[]"]),register(78,1,"Comparison",["i"]),register(79,1,"SpaceToDepth",["i"]),register(80,1,"DepthToSpace",["i"]),register(81,1,"Reverse",[]),register(82,1,"SparseToDense",["i","i","i"]),register(83,1,"Ceil",[]),register(84,1,"SquaredDifference",[]),register(85,1,"Round",[]),register(86,1,"ZerosLike",[]),register(87,1,"Clip",["f","f"]),register(88,1,"MatMul",[]),register(89,1,"ReduceL2",["i","i"]),register(90,1,"Unsqueeze",["i[]"]),register(91,1,"Num",[]);const e=new tengine.BinaryReader(t);this._majorVersion=e.uint16(),this._minorVersion=e.uint16(),this._compileVersion=e.uint16(),e.skip(2),e.seek(e.uint32()),this._originalFormat=e.int32(),this._subFormat=e.int32(),this._graphs=[];const s=e.uint32s();for(const t of s){e.seek(t);const s={};s.id=e.int32(),s.graphLayout=e.int32(),s.originalLayout=e.int32(),s.inputs=e.uint32s(),s.outputs=e.uint32s();const n=e.uint32s(),a=e.uint32s(),r=e.uint32s();s.name=e.string(),s.nodes=[],s.tensors=[],this._graphs.push(s);for(const t of n){e.seek(t);const n={};n.id=e.int32(),n.inputs=e.uint32s(),n.outputs=e.uint32s();const a=e.int32();n.name=e.string();const r=e.uint32s();n.dynamicShape=!!e.boolean(),e.seek(a),n.version=e.int32();const o=e.int32(),h=e.uint32(),u=o.toString()+":"+n.version.toString(),p=i.has(u)?i.get(u):null;n.type=p?p.name:o.toString();const c=p?p.params:[];if(n.params=[],h){e.seek(h);for(const t of c)switch("boolean"!==t&&e.align(4),t){case"i":n.params.push(e.int32());break;case"f":n.params.push(e.float32());break;case"i[]":n.params.push(e.int32s());break;case"f[]":n.params.push(e.float32s());break;case"boolean":n.params.push(e.boolean());break;case"string":n.params.push(e.string());break;case"anchors":n.params.push(e.anchors(4));break;default:throw new tengine.Error("Unsupported param type '"+t+"' in '"+n.type+"'.")}}"Slice"===n.type&&(n.params[6]=5==this._originalFormat?n.params[6]:0),n.attributes=[];for(const t of r){e.seek(t);const i=e.string(),s=e.string(),a=e.int32();n.attributes.push({name:i,value:s,type:a})}"Const"!==n.type&&s.nodes.push(n)}const o=[];for(const t of r){e.seek(t);const i=e.uint32();e.seek(e.int32()),o.push(e.bytes(i))}for(const t of a){e.seek(t);const i={};i.id=e.int32(),i.buffer=o[e.int32()],i.dims=e.int32s(),i.name=e.string();const n=e.int32();i.layout=e.int32(),i.type=e.int32(),i.dataType=e.int32(),n&&(e.seek(n),i.quantparams={zeroPoint:e.int32(),scale:e.float32(),width:e.int32()}),s.tensors.push(i)}for(const t of s.nodes)if("Convolution"===t.type)switch(s.graphLayout){case 0:t.params[6]=s.tensors[t.inputs[1]].dims[1];break;case 1:t.params[6]=s.tensors[t.inputs[1]].dims[3]}}}get version(){return this._majorVersion+"."+this._minorVersion}get source(){switch(this._originalFormat){case 0:return"";case 1:return"Tengine";case 2:return"Caffe";case 3:return"ONNX";case 4:return"MXNet";case 5:return"TensorFlow";case 6:return"TensorFlow Lite";case 7:return"Darknet";case 8:return"DLA v"+this._subFormat;default:throw new tengine.Error("Unknown source '"+this._originalFormat.toString()+"'.")}}get graphs(){return this._graphs}},tengine.BinaryReader=class{constructor(t){this._buffer=t,this._dataView=new DataView(t.buffer,t.byteOffset,t.byteLength),this._position=0}seek(t){if(this._position=t,this._position>this._buffer.length)throw new tengine.Error("Expected "+(this._position-this._buffer.length)+" more bytes. The file might be corrupted. Unexpected end of file.")}skip(t){if(this._position+=t,this._position>this._buffer.length)throw new tengine.Error("Expected "+(this._position-this._buffer.length)+" more bytes. The file might be corrupted. Unexpected end of file.")}align(t){this._position%t!=0&&this.skip(t-this._position%t)}bytes(t){const i=this._position;return this.skip(t),this._buffer.slice(i,this._position)}byte(){return this.skip(1),this._dataView.getUint8(this._position)}boolean(){return 0==this.byte()}uint16(){const t=this._position;return this.skip(2),this._dataView.getUint16(t,!0)}uint32(){const t=this._position;return this.skip(4),this._dataView.getUint32(t,!0)}uint32s(){const t=[],i=this.uint32();if(i){const e=this._position;this.seek(i);const s=this.uint32();for(let i=0;i<s;i++)t.push(this.uint32());this.seek(e)}return t}int32(){const t=this._position;return this.skip(4),this._dataView.getInt32(t,!0)}int32s(){const t=[],i=this.uint32();if(i){const e=this._position;this.seek(i);const s=this.uint32();for(let i=0;i<s;i++)t.push(this.int32());this.seek(e)}return t}float32(){const t=this._position;return this.skip(4),this._dataView.getFloat32(t,!0)}float32s(){const t=[],i=this.uint32();if(i){const e=this._position;this.seek(i);const s=this.uint32();for(let i=0;i<s;i++)t.push(this.float32());this.seek(e)}return t}anchors(t){const i=[],e=this.uint32();if(e){const s=this._position;this.seek(e);const n=this.uint32();for(let e=0;e<n;e++){const e=[];for(let i=0;i<t;i++)e.push(this.float32());i.push(e)}this.seek(s)}return i}string(){const t=this.uint32();let i="";if(t){const e=this._position;this.seek(t);const s=this.uint32();this.seek(this.uint32());for(let t=0;t<s-1;t++)i+=String.fromCharCode(this._buffer[this._position++]);this.seek(e)}return i}},tengine.Error=class extends Error{constructor(t){super(t),this.name="Error loading Tengine model."}},"undefined"!=typeof module&&"object"==typeof module.exports&&(module.exports.ModelFactory=tengine.ModelFactory);
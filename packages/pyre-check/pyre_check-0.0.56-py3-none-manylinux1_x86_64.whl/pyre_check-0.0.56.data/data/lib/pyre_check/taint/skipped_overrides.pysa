# There are some built in and heavily overridden functions. The override models
# for these do not provide taint value, so skipping these speeds up the runtime of
# Pysa immensely without adversely affecting taint results.

# object and type are large catch-alls, and don't provide much signal.
def object.__init__(self) -> SkipOverrides: ...
def object.__eq__(self, o) -> SkipOverrides: ...
def object.__ne__(self, o) -> SkipOverrides: ...
def object.__repr__(self) -> SkipOverrides: ...
def object.__hash__(self) -> SkipOverrides: ...
def object.__reduce__(self) -> SkipOverrides: ...
def object.__str__(self) -> SkipOverrides: ...

def type.__call__(self) -> SkipOverrides: ...
def type.__new__(self) -> SkipOverrides: ...
def type.__init__(self) -> SkipOverrides: ...

# Named tuples are code generated to inherit from NamedTuple.__init__.
def typing.NamedTuple.__init__(self, typename, fields = ..., **kwargs) -> SkipOverrides: ...

# Some common collections.
def typing.Collection.__len__(self) -> SkipOverrides: ...
def typing.Iterable.__iter__(self) -> SkipOverrides: ...
def typing.Mapping.__contains__(self, o) -> SkipOverrides: ...
def typing.Mapping.__getitem__(self, k) -> SkipOverrides: ...
def typing.Sequence.__contains__(self, x) -> SkipOverrides: ...
def typing.Sequence.__getitem__(self, k) -> SkipOverrides: ...
def typing.Sequence.__iter__(self) -> SkipOverrides: ...
def typing.Sequence.__reversed__(self) -> SkipOverrides: ...
def typing.Sequence.count(self, value) -> SkipOverrides: ...
def typing.Sequence.index(self, value, start = ..., stop = ...) -> SkipOverrides: ...
def typing.AbstractSet.__contains__(self, x) -> SkipOverrides: ...
def typing.AbstractSet.isdisjoint(self, other) -> SkipOverrides: ...

def list.extend(self, __iterable) -> SkipOverrides: ...
def list.append(self, __object) -> SkipOverrides: ...
def list.insert(self, __index, __object) -> SkipOverrides: ...

def dict.__setitem__(self, k, v) -> SkipOverrides: ...

#ifndef __OSI_EXT_H__
#define __OSI_EXT_H__
/*
 * DO NOT MODIFY. This file is automatically generated by scripts/apigen.py,
 * based on the <plugin>_int.h file in your plugin directory.
 *
 * Note: Function pointers for API calls are declared as extern.
 * The definition of the pointers is guarded by the PLUGIN_MAIN macro.
 * This plugin is defined only for the compilation unit matching the
 * name of the plugin.
 * This allows us to initialize API function pointers once, in the main
 * compilation unit, rather than in every compilation unit.
 */
#include <dlfcn.h>
#include "panda/plugin.h"

typedef GArray *(*get_process_handles_t)(CPUState *cpu);
extern get_process_handles_t __get_process_handles;
#ifdef PLUGIN_MAIN
get_process_handles_t __get_process_handles = NULL;
#endif
static inline GArray * get_process_handles(CPUState *cpu);
static inline GArray * get_process_handles(CPUState *cpu) {
    assert(__get_process_handles);
    return __get_process_handles(cpu);
}

typedef OsiThread *(*get_current_thread_t)(CPUState *cpu);
extern get_current_thread_t __get_current_thread;
#ifdef PLUGIN_MAIN
get_current_thread_t __get_current_thread = NULL;
#endif
static inline OsiThread * get_current_thread(CPUState *cpu);
static inline OsiThread * get_current_thread(CPUState *cpu) {
    assert(__get_current_thread);
    return __get_current_thread(cpu);
}

typedef GArray *(*get_modules_t)(CPUState *cpu);
extern get_modules_t __get_modules;
#ifdef PLUGIN_MAIN
get_modules_t __get_modules = NULL;
#endif
static inline GArray * get_modules(CPUState *cpu);
static inline GArray * get_modules(CPUState *cpu) {
    assert(__get_modules);
    return __get_modules(cpu);
}

typedef GArray *(*get_mappings_t)(CPUState *cpu, OsiProc *p);
extern get_mappings_t __get_mappings;
#ifdef PLUGIN_MAIN
get_mappings_t __get_mappings = NULL;
#endif
static inline GArray * get_mappings(CPUState *cpu, OsiProc *p);
static inline GArray * get_mappings(CPUState *cpu, OsiProc *p) {
    assert(__get_mappings);
    return __get_mappings(cpu,p);
}

typedef GArray *(*get_processes_t)(CPUState *cpu);
extern get_processes_t __get_processes;
#ifdef PLUGIN_MAIN
get_processes_t __get_processes = NULL;
#endif
static inline GArray * get_processes(CPUState *cpu);
static inline GArray * get_processes(CPUState *cpu) {
    assert(__get_processes);
    return __get_processes(cpu);
}

typedef OsiProc *(*get_current_process_t)(CPUState *cpu);
extern get_current_process_t __get_current_process;
#ifdef PLUGIN_MAIN
get_current_process_t __get_current_process = NULL;
#endif
static inline OsiProc * get_current_process(CPUState *cpu);
static inline OsiProc * get_current_process(CPUState *cpu) {
    assert(__get_current_process);
    return __get_current_process(cpu);
}

typedef OsiModule*(*get_one_module_t)(GArray *osimodules, unsigned int idx);
extern get_one_module_t __get_one_module;
#ifdef PLUGIN_MAIN
get_one_module_t __get_one_module = NULL;
#endif
static inline OsiModule* get_one_module(GArray *osimodules, unsigned int idx);
static inline OsiModule* get_one_module(GArray *osimodules, unsigned int idx) {
    assert(__get_one_module);
    return __get_one_module(osimodules,idx);
}

typedef OsiProc*(*get_one_proc_t)(GArray *osiprocs, unsigned int idx);
extern get_one_proc_t __get_one_proc;
#ifdef PLUGIN_MAIN
get_one_proc_t __get_one_proc = NULL;
#endif
static inline OsiProc* get_one_proc(GArray *osiprocs, unsigned int idx);
static inline OsiProc* get_one_proc(GArray *osiprocs, unsigned int idx) {
    assert(__get_one_proc);
    return __get_one_proc(osiprocs,idx);
}

typedef void(*cleanup_garray_t)(GArray *g);
extern cleanup_garray_t __cleanup_garray;
#ifdef PLUGIN_MAIN
cleanup_garray_t __cleanup_garray = NULL;
#endif
static inline void cleanup_garray(GArray *g);
static inline void cleanup_garray(GArray *g) {
    assert(__cleanup_garray);
    return __cleanup_garray(g);
}

typedef OsiProcHandle *(*get_current_process_handle_t)(CPUState *cpu);
extern get_current_process_handle_t __get_current_process_handle;
#ifdef PLUGIN_MAIN
get_current_process_handle_t __get_current_process_handle = NULL;
#endif
static inline OsiProcHandle * get_current_process_handle(CPUState *cpu);
static inline OsiProcHandle * get_current_process_handle(CPUState *cpu) {
    assert(__get_current_process_handle);
    return __get_current_process_handle(cpu);
}

typedef OsiProc *(*get_process_t)(CPUState *cpu, const OsiProcHandle *h);
extern get_process_t __get_process;
#ifdef PLUGIN_MAIN
get_process_t __get_process = NULL;
#endif
static inline OsiProc * get_process(CPUState *cpu, const OsiProcHandle *h);
static inline OsiProc * get_process(CPUState *cpu, const OsiProcHandle *h) {
    assert(__get_process);
    return __get_process(cpu,h);
}

typedef target_pid_t(*get_process_pid_t)(CPUState *cpu, const OsiProcHandle *h);
extern get_process_pid_t __get_process_pid;
#ifdef PLUGIN_MAIN
get_process_pid_t __get_process_pid = NULL;
#endif
static inline target_pid_t get_process_pid(CPUState *cpu, const OsiProcHandle *h);
static inline target_pid_t get_process_pid(CPUState *cpu, const OsiProcHandle *h) {
    assert(__get_process_pid);
    return __get_process_pid(cpu,h);
}

typedef target_pid_t(*get_process_ppid_t)(CPUState *cpu, const OsiProcHandle *h);
extern get_process_ppid_t __get_process_ppid;
#ifdef PLUGIN_MAIN
get_process_ppid_t __get_process_ppid = NULL;
#endif
static inline target_pid_t get_process_ppid(CPUState *cpu, const OsiProcHandle *h);
static inline target_pid_t get_process_ppid(CPUState *cpu, const OsiProcHandle *h) {
    assert(__get_process_ppid);
    return __get_process_ppid(cpu,h);
}

bool init_osi_api(void);

#ifdef PLUGIN_MAIN
#define API_PLUGIN_NAME "osi"
#define IMPORT_PPP(module, func_name) { \
    __##func_name = (func_name##_t) dlsym(module, #func_name); \
    char *err = dlerror(); \
    if (err) { \
        printf("Couldn't find %s function in library %s.\n", #func_name, API_PLUGIN_NAME); \
        printf("Error: %s\n", err); \
        return false; \
    } \
}
bool init_osi_api(void) {
    void *module = panda_get_plugin_by_name(API_PLUGIN_NAME);
    if (!module) {
        fprintf(stderr, "Couldn't load %s plugin: %s\n", API_PLUGIN_NAME, dlerror());
        return false;
    }
    IMPORT_PPP(module, get_process_handles)
    IMPORT_PPP(module, get_current_thread)
    IMPORT_PPP(module, get_modules)
    IMPORT_PPP(module, get_mappings)
    IMPORT_PPP(module, get_processes)
    IMPORT_PPP(module, get_current_process)
    IMPORT_PPP(module, get_one_module)
    IMPORT_PPP(module, get_one_proc)
    IMPORT_PPP(module, cleanup_garray)
    IMPORT_PPP(module, get_current_process_handle)
    IMPORT_PPP(module, get_process)
    IMPORT_PPP(module, get_process_pid)
    IMPORT_PPP(module, get_process_ppid)
    return true;
}
#undef API_PLUGIN_NAME
#undef IMPORT_PPP
#endif

#endif


"""
Auto-generated type declaration to provide c-definitions for the cffi interface. It's highly unlikely you actually need this.
If you simply need a list of callbacks consult the manual in main PANDA.
"""
# NOTE: panda_datatypes.py is auto generated by the script create_panda_datatypes.py
# Please do not tinker with it!  Instead, fix the script that generates it
from enum import Enum
from ctypes import *
from collections import namedtuple
from ..ffi_importer import ffi

if True:
    import os
    include_dir = os.path.abspath(os.path.join(*[os.path.dirname(__file__), "..", "..", "pandare", "data", "pypanda", "include"]))
else:
    include_dir = "/home/andrew/git/panda/panda/python/core/pandare/include"

def define_clean_header(ffi, fname):
    '''Convenience function to pull in headers from file in C'''
    #print("Pulling cdefs from ", fname)
    # CFFI can't handle externs, but sometimes we have to extern C (as opposed to 
    r = open(fname).read()
    for line in r.split("\n"):
        assert("extern \"C\" {" not in line), "Externs unsupported by CFFI. Change {} to a single line without braces".format(r)
    r = r.replace("extern \"C\" ", "") # This allows inline externs like 'extern "C" void foo(...)'
    try:
        ffi.cdef(r)
    except Exception as e: # it's a cffi.CDefError, but cffi isn't imported
        print(f"\nError parsing header from {fname}\n")
        raise

from os import environ

if "PANDA_BITS" not in environ and "PANDA_ARCH" not in environ:
    print("Environment lacks PANDA_BITS and PANDA_ARCH. Assuming we're in documentation mode for 32-bit i386")
    bits = 32
    arch = "i386"
else:
    # If only one is set that's weird and we should crash
    bits = int(environ["PANDA_BITS"])
    arch = environ["PANDA_ARCH"]

# For OSI
ffi.cdef("typedef void GArray;")
ffi.cdef("typedef int target_pid_t;")

ffi.cdef("typedef uint"+str(bits)+"_t target_ulong;")
ffi.cdef("typedef int"+str(bits)+"_t target_long;")
#define_clean_header(ffi, include_dir + "/pthreadtypes.h")

# PPP Headers
# Syscalls - load architecture-specific headers
if arch == "i386":
    define_clean_header(ffi, include_dir + "/panda_datatypes_X86_32.h")
    define_clean_header(ffi, include_dir + "/syscalls_ext_typedefs_x86.h")
elif arch == "x86_64":
    define_clean_header(ffi, include_dir + "/panda_datatypes_X86_64.h")
    define_clean_header(ffi, include_dir + "/syscalls_ext_typedefs_x64.h")
elif arch == "arm":
    define_clean_header(ffi, include_dir + "/panda_datatypes_ARM_32.h")
    define_clean_header(ffi, include_dir + "/syscalls_ext_typedefs_arm.h")
elif arch == "ppc" and int(bits) == 32:
    define_clean_header(ffi, include_dir + "/panda_datatypes_PPC_32.h")
    print('WARNING: no syscalls support for PPC 32')
elif arch == "ppc" and int(bits) == 64:
    define_clean_header(ffi, include_dir + "/panda_datatypes_PPC_64.h")
    print('WARNING: no syscalls support for PPC 64')
elif arch == "mips" and int(bits) == 32:
    define_clean_header(ffi, include_dir + "/panda_datatypes_MIPS_32.h")
    define_clean_header(ffi, include_dir + "/syscalls_ext_typedefs_mips.h")
elif arch == "mipsel" and int(bits) == 32:
    define_clean_header(ffi, include_dir + "/panda_datatypes_MIPS_32.h") # XXX?
    define_clean_header(ffi, include_dir + "/syscalls_ext_typedefs_mips.h")
else:
    print("PANDA_DATATYPES: Architecture not supported")

# Define some common panda datatypes
#define_clean_header(ffi, include_dir + "/panda_qemu_support.h")
define_clean_header(ffi, include_dir + "/panda_datatypes.h")

# Now syscalls2 common:
define_clean_header(ffi, include_dir + "/syscalls2_info.h")

# A few more CFFI types now that we have common datatypes
# Manually define syscall_ctx_t - taken from syscalls2/generated/syscalls_ext_typedefs.h
# It uses a #DEFINES as part of the array size so CFFI can't hanle that :
ffi.cdef(''' typedef struct syscall_ctx {
        int no;               /**< number */
        target_ptr_t asid;    /**< calling process asid */
        target_ptr_t retaddr; /**< return address */
        uint8_t args[17]
             [64]; /**< arguments */
    } syscall_ctx_t;
''')

define_clean_header(ffi, include_dir + "/syscalls_ext_typedefs.h")

define_clean_header(ffi, include_dir + "/callstack_instr.h")

define_clean_header(ffi, include_dir + "/hooks2_ppp.h")
# END PPP headers

define_clean_header(ffi, include_dir + "/breakpoints.h")
define_clean_header(ffi, include_dir + "/osi_types.h")
define_clean_header(ffi, include_dir + "/addr.h")
define_clean_header(ffi, include_dir + "/query_res.h")
define_clean_header(ffi, include_dir + "/taint2_int_fns.h")
define_clean_header(ffi, include_dir + "/hooks_int_fns.h")
define_clean_header(ffi, include_dir + "/signal_int_fns.h")
define_clean_header(ffi, include_dir + "/callstack_instr_int_fns.h")
define_clean_header(ffi, include_dir + "/osi_linux_int_fns.h")
define_clean_header(ffi, include_dir + "/osi_int_fns.h")
define_clean_header(ffi, include_dir + "/syscalls2_int_fns.h")
define_clean_header(ffi, include_dir + "/rr_api.h")
define_clean_header(ffi, include_dir + "/plugin.h")
define_clean_header(ffi, include_dir + "/common.h")
define_clean_header(ffi, include_dir + "/hooks2.h")

# so we need access to some data structures, but don't actually
# want to open all of libpanda yet because we don't have all the
# file information. So we just open libc to access this.
C = ffi.dlopen(None)

class PandaState(Enum):
    UNINT = 1
    INIT_DONE = 2
    IN_RECORD = 3
    IN_REPLAY = 4
    
PandaCB = namedtuple("PandaCB", "init \
before_block_translate \
after_block_translate \
before_block_exec_invalidate_opt \
before_tcg_codegen \
before_block_exec \
after_block_exec \
insn_translate \
insn_exec \
after_insn_translate \
after_insn_exec \
virt_mem_before_read \
virt_mem_before_write \
phys_mem_before_read \
phys_mem_before_write \
virt_mem_after_read \
virt_mem_after_write \
phys_mem_after_read \
phys_mem_after_write \
mmio_after_read \
mmio_before_write \
hd_read \
hd_write \
guest_hypercall \
monitor \
cpu_restore_state \
before_loadvm \
asid_changed \
replay_hd_transfer \
replay_net_transfer \
replay_serial_receive \
replay_serial_read \
replay_serial_send \
replay_serial_write \
replay_before_dma \
replay_after_dma \
replay_handle_packet \
after_cpu_exec_enter \
before_cpu_exec_exit \
after_machine_init \
after_loadvm \
top_loop \
during_machine_init \
main_loop_wait \
pre_shutdown \
unassigned_io_read \
unassigned_io_write \
before_handle_exception \
before_handle_interrupt ")

pcb = PandaCB(init = ffi.callback("bool(void*)"),
before_block_translate = ffi.callback("void (CPUState *, target_ptr_t)"),
after_block_translate = ffi.callback("void (CPUState *, TranslationBlock *)"),
before_block_exec_invalidate_opt = ffi.callback("bool (CPUState *, TranslationBlock *)"),
before_tcg_codegen = ffi.callback("void (CPUState *, TranslationBlock *)"),
before_block_exec = ffi.callback("void (CPUState *, TranslationBlock *)"),
after_block_exec = ffi.callback("void (CPUState *, TranslationBlock *, uint8_t)"),
insn_translate = ffi.callback("bool (CPUState *, target_ptr_t)"),
insn_exec = ffi.callback("int (CPUState *, target_ptr_t)"),
after_insn_translate = ffi.callback("bool (CPUState *, target_ptr_t)"),
after_insn_exec = ffi.callback("int (CPUState *, target_ptr_t)"),
virt_mem_before_read = ffi.callback("void (CPUState *, target_ptr_t, target_ptr_t, size_t)"),
virt_mem_before_write = ffi.callback("void (CPUState *, target_ptr_t, target_ptr_t, size_t, uint8_t *)"),
phys_mem_before_read = ffi.callback("void (CPUState *, target_ptr_t, target_ptr_t, size_t)"),
phys_mem_before_write = ffi.callback("void (CPUState *, target_ptr_t, target_ptr_t, size_t, uint8_t *)"),
virt_mem_after_read = ffi.callback("void (CPUState *, target_ptr_t, target_ptr_t, size_t, uint8_t *)"),
virt_mem_after_write = ffi.callback("void (CPUState *, target_ptr_t, target_ptr_t, size_t, uint8_t *)"),
phys_mem_after_read = ffi.callback("void (CPUState *, target_ptr_t, target_ptr_t, size_t, uint8_t *)"),
phys_mem_after_write = ffi.callback("void (CPUState *, target_ptr_t, target_ptr_t, size_t, uint8_t *)"),
mmio_after_read = ffi.callback("void (CPUState *, target_ptr_t, target_ptr_t, size_t, uint64_t *)"),
mmio_before_write = ffi.callback("void (CPUState *, target_ptr_t, target_ptr_t, size_t, uint64_t *)"),
hd_read = ffi.callback("void (CPUState *)"),
hd_write = ffi.callback("void (CPUState *)"),
guest_hypercall = ffi.callback("bool (CPUState *)"),
monitor = ffi.callback("int (Monitor *, const char *)"),
cpu_restore_state = ffi.callback("void (CPUState *, TranslationBlock *)"),
before_loadvm = ffi.callback("int (void)"),
asid_changed = ffi.callback("bool (CPUState *, target_ptr_t, target_ptr_t)"),
replay_hd_transfer = ffi.callback("void (CPUState *, uint32_t, target_ptr_t, target_ptr_t, size_t)"),
replay_net_transfer = ffi.callback("void (CPUState *, uint32_t, uint64_t, uint64_t, size_t)"),
replay_serial_receive = ffi.callback("void (CPUState *, target_ptr_t, uint8_t)"),
replay_serial_read = ffi.callback("void (CPUState *, target_ptr_t, uint32_t, uint8_t)"),
replay_serial_send = ffi.callback("void (CPUState *, target_ptr_t, uint8_t)"),
replay_serial_write = ffi.callback("void (CPUState *, target_ptr_t, uint32_t, uint8_t)"),
replay_before_dma = ffi.callback("void (CPUState *, const uint8_t *, hwaddr, size_t, bool)"),
replay_after_dma = ffi.callback("void (CPUState *, const uint8_t *, hwaddr, size_t, bool)"),
replay_handle_packet = ffi.callback("void (CPUState *, uint8_t *, size_t, uint8_t, uint64_t)"),
after_cpu_exec_enter = ffi.callback("void (CPUState *)"),
before_cpu_exec_exit = ffi.callback("void (CPUState *, bool)"),
after_machine_init = ffi.callback("void (CPUState *)"),
after_loadvm = ffi.callback("void (CPUState *)"),
top_loop = ffi.callback("void (CPUState *)"),
during_machine_init = ffi.callback("void (MachineState *)"),
main_loop_wait = ffi.callback("void (void)"),
pre_shutdown = ffi.callback("void (void)"),
unassigned_io_read = ffi.callback("bool (CPUState *, target_ptr_t, hwaddr, size_t, uint64_t *)"),
unassigned_io_write = ffi.callback("bool (CPUState *, target_ptr_t, hwaddr, size_t, uint64_t)"),
before_handle_exception = ffi.callback("int32_t (CPUState *, int32_t)"),
before_handle_interrupt = ffi.callback("int32_t (CPUState *, int32_t)"))


pandacbtype = namedtuple("pandacbtype", "name number")


callback_dictionary = {
pcb.init : pandacbtype("init", -1),
pcb.before_block_translate : pandacbtype("before_block_translate", C.PANDA_CB_BEFORE_BLOCK_TRANSLATE),
pcb.after_block_translate : pandacbtype("after_block_translate", C.PANDA_CB_AFTER_BLOCK_TRANSLATE),
pcb.before_block_exec_invalidate_opt : pandacbtype("before_block_exec_invalidate_opt", C.PANDA_CB_BEFORE_BLOCK_EXEC_INVALIDATE_OPT),
pcb.before_tcg_codegen : pandacbtype("before_tcg_codegen", C.PANDA_CB_BEFORE_TCG_CODEGEN),
pcb.before_block_exec : pandacbtype("before_block_exec", C.PANDA_CB_BEFORE_BLOCK_EXEC),
pcb.after_block_exec : pandacbtype("after_block_exec", C.PANDA_CB_AFTER_BLOCK_EXEC),
pcb.insn_translate : pandacbtype("insn_translate", C.PANDA_CB_INSN_TRANSLATE),
pcb.insn_exec : pandacbtype("insn_exec", C.PANDA_CB_INSN_EXEC),
pcb.after_insn_translate : pandacbtype("after_insn_translate", C.PANDA_CB_AFTER_INSN_TRANSLATE),
pcb.after_insn_exec : pandacbtype("after_insn_exec", C.PANDA_CB_AFTER_INSN_EXEC),
pcb.virt_mem_before_read : pandacbtype("virt_mem_before_read", C.PANDA_CB_VIRT_MEM_BEFORE_READ),
pcb.virt_mem_before_write : pandacbtype("virt_mem_before_write", C.PANDA_CB_VIRT_MEM_BEFORE_WRITE),
pcb.phys_mem_before_read : pandacbtype("phys_mem_before_read", C.PANDA_CB_PHYS_MEM_BEFORE_READ),
pcb.phys_mem_before_write : pandacbtype("phys_mem_before_write", C.PANDA_CB_PHYS_MEM_BEFORE_WRITE),
pcb.virt_mem_after_read : pandacbtype("virt_mem_after_read", C.PANDA_CB_VIRT_MEM_AFTER_READ),
pcb.virt_mem_after_write : pandacbtype("virt_mem_after_write", C.PANDA_CB_VIRT_MEM_AFTER_WRITE),
pcb.phys_mem_after_read : pandacbtype("phys_mem_after_read", C.PANDA_CB_PHYS_MEM_AFTER_READ),
pcb.phys_mem_after_write : pandacbtype("phys_mem_after_write", C.PANDA_CB_PHYS_MEM_AFTER_WRITE),
pcb.mmio_after_read : pandacbtype("mmio_after_read", C.PANDA_CB_MMIO_AFTER_READ),
pcb.mmio_before_write : pandacbtype("mmio_before_write", C.PANDA_CB_MMIO_BEFORE_WRITE),
pcb.hd_read : pandacbtype("hd_read", C.PANDA_CB_HD_READ),
pcb.hd_write : pandacbtype("hd_write", C.PANDA_CB_HD_WRITE),
pcb.guest_hypercall : pandacbtype("guest_hypercall", C.PANDA_CB_GUEST_HYPERCALL),
pcb.monitor : pandacbtype("monitor", C.PANDA_CB_MONITOR),
pcb.cpu_restore_state : pandacbtype("cpu_restore_state", C.PANDA_CB_CPU_RESTORE_STATE),
pcb.before_loadvm : pandacbtype("before_loadvm", C.PANDA_CB_BEFORE_LOADVM),
pcb.asid_changed : pandacbtype("asid_changed", C.PANDA_CB_ASID_CHANGED),
pcb.replay_hd_transfer : pandacbtype("replay_hd_transfer", C.PANDA_CB_REPLAY_HD_TRANSFER),
pcb.replay_net_transfer : pandacbtype("replay_net_transfer", C.PANDA_CB_REPLAY_NET_TRANSFER),
pcb.replay_serial_receive : pandacbtype("replay_serial_receive", C.PANDA_CB_REPLAY_SERIAL_RECEIVE),
pcb.replay_serial_read : pandacbtype("replay_serial_read", C.PANDA_CB_REPLAY_SERIAL_READ),
pcb.replay_serial_send : pandacbtype("replay_serial_send", C.PANDA_CB_REPLAY_SERIAL_SEND),
pcb.replay_serial_write : pandacbtype("replay_serial_write", C.PANDA_CB_REPLAY_SERIAL_WRITE),
pcb.replay_before_dma : pandacbtype("replay_before_dma", C.PANDA_CB_REPLAY_BEFORE_DMA),
pcb.replay_after_dma : pandacbtype("replay_after_dma", C.PANDA_CB_REPLAY_AFTER_DMA),
pcb.replay_handle_packet : pandacbtype("replay_handle_packet", C.PANDA_CB_REPLAY_HANDLE_PACKET),
pcb.after_cpu_exec_enter : pandacbtype("after_cpu_exec_enter", C.PANDA_CB_AFTER_CPU_EXEC_ENTER),
pcb.before_cpu_exec_exit : pandacbtype("before_cpu_exec_exit", C.PANDA_CB_BEFORE_CPU_EXEC_EXIT),
pcb.after_machine_init : pandacbtype("after_machine_init", C.PANDA_CB_AFTER_MACHINE_INIT),
pcb.after_loadvm : pandacbtype("after_loadvm", C.PANDA_CB_AFTER_LOADVM),
pcb.top_loop : pandacbtype("top_loop", C.PANDA_CB_TOP_LOOP),
pcb.during_machine_init : pandacbtype("during_machine_init", C.PANDA_CB_DURING_MACHINE_INIT),
pcb.main_loop_wait : pandacbtype("main_loop_wait", C.PANDA_CB_MAIN_LOOP_WAIT),
pcb.pre_shutdown : pandacbtype("pre_shutdown", C.PANDA_CB_PRE_SHUTDOWN),
pcb.unassigned_io_read : pandacbtype("unassigned_io_read", C.PANDA_CB_UNASSIGNED_IO_READ),
pcb.unassigned_io_write : pandacbtype("unassigned_io_write", C.PANDA_CB_UNASSIGNED_IO_WRITE),
pcb.before_handle_exception : pandacbtype("before_handle_exception", C.PANDA_CB_BEFORE_HANDLE_EXCEPTION),
pcb.before_handle_interrupt : pandacbtype("before_handle_interrupt", C.PANDA_CB_BEFORE_HANDLE_INTERRUPT)}

pandacbtype.__doc__ = '''stores the names and numbers for callbacks'''
PandaCB.__doc__ = '''custom named tuple to handle callbacks. Each element is a callback except init.'''        

import json
from typing import *

from dataclasses_json import DataClassJsonMixin
from functional import Some, OptionNone
from typing.io import *

from openapi_parser.model import ModelClass, ModelSchema
from .abstract_writer import Writer, yielder, writer

class ClassWriter(Writer):
    def dump_class_description(self, cls: ModelClass, *, cls_all_required_properties: List[str] = None) -> Iterator[str]:
        if (cls_all_required_properties is None):
            cls_all_required_properties = cls.all_required_properties
        
        yield self.TRIPLE_QUOT
        if (cls.description is not None):
            yield from cls.description.splitlines()
            yield
        
        if (cls_all_required_properties):
            yield "Required Properties:"
            yield from (f" - {self.object_valid_name_filter(self.field_name_pretty(f_name))}" for f_name in cls_all_required_properties)
            yield
        
        if (cls.example is not None):
            example = cls.example
            if (not isinstance(example, str)):
                example = json.dumps(example, indent=self.INDENT_SIZE)
            
            yield "Example:"
            with self.indent():
                yield self.TRIPLE_BACKQUOT + 'json'
                yield from example.splitlines()
                yield self.TRIPLE_BACKQUOT
            yield
        
        yield "Generated by Python OpenAPI Parser"
        yield f"Class {cls.pretty_path}"
        yield f"Schema {cls.path}"
        yield self.TRIPLE_QUOT
        yield
    
    def dump_property(self, name: str, prop: ModelSchema, *, only_if_has_default: Optional[bool] = None, is_required: bool = True) -> Iterator[str]:
        f_type = Some(self.class_name_pretty(prop.cls)) if isinstance(prop, ModelSchema) else OptionNone
        f_default = prop.default
        field_name_pretty = self.field_name_pretty(name)
        actual_name = self.object_valid_name_filter(field_name_pretty)
        if (not is_required):
            f_type = f_type.map('Optional[{}]'.format)
            f_default = f_default or (Some(None) if not is_required else OptionNone)
        
        if (only_if_has_default is not None and f_default.is_empty == only_if_has_default):
            return
        
        f_constructor = dict()
        f_constructor_meta = dict()
        if (prop.filter.encoder is not None):
            f_constructor_meta['encoder'] = self.ref_name_pretty(prop.filter.encoder)
        if (prop.filter.decoder is not None):
            f_constructor_meta['decoder'] = self.ref_name_pretty(prop.filter.decoder)
        if (actual_name != field_name_pretty):
            f_constructor_meta['field_name'] = '{!r}'.format(name)
        
        if (f_constructor_meta):
            f_constructor['metadata'] = f"config({', '.join(f'{k}={v}' for k, v in f_constructor_meta.items())})"
        if (prop.default.non_empty and isinstance(prop.default.get, (list, dict, set, tuple))):
            if (f_default.get):
                f_constructor['default_factory'] = f'lambda: {prop.default.get!r}'
            else:
                f_constructor['default_factory'] = type(prop.default.get).__name__
        if (f_constructor):
            if (f_default.non_empty):
                if ('default_factory' not in f_constructor):
                    f_constructor['default'] = '{!r}'.format(f_default.get)
            f_value = Some(f"field({', '.join(f'{k}={v}' for k, v in f_constructor.items())})")
        else:
            f_value = f_default.map('{!r}'.format)
        
        yield actual_name + f_type.map(': {}'.format).get_or_else('') + f_value.map(' = {}'.format).get_or_else('')
    
    def dump_class(self, cls: ModelClass) -> Iterator[str]:
        cls_name = self.object_valid_name_filter(self.class_name_pretty(cls))
        cls_all_req_properties = cls.all_required_properties
        
        yield '@dataclass_json(letter_case=LetterCase.CAMEL)'
        yield '@dataclass'
        yield f"class {cls_name}({', '.join(self.object_valid_name_filter(self.class_name_pretty(p)) for p in (cls.parents + [ DataClassJsonMixin ]))}):"
        
        with self.indent():
            yield from self.dump_class_description(cls, cls_all_required_properties=cls_all_req_properties)
            for f_name, f_data in cls.all_properties_iter:
                yield from self.dump_property(f_name, f_data, only_if_has_default=False, is_required=f_name in cls_all_req_properties)
            for f_name, f_data in cls.all_properties_iter:
                yield from self.dump_property(f_name, f_data, only_if_has_default=True, is_required=f_name in cls_all_req_properties)
        
        yield
    
    # region Writers
    @yielder
    def yield_class(self, cls: ModelClass) -> Iterator[Tuple[int, str]]:
        # noinspection PyTypeChecker
        return self.dump_class(cls)
    
    @overload
    def write_class(self, cls: ModelClass) -> Iterator[str]:
        pass
    # noinspection PyOverloads
    @overload
    def write_class(self, cls: ModelClass, *, stream: TextIO) -> None:
        pass
    @writer
    def write_class(self, cls: ModelClass) -> Optional[Iterator[str]]:
        # noinspection PyTypeChecker
        return self.yield_class(cls)
    # endregion


__all__ = \
[
    'ClassWriter',
]

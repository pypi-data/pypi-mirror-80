import json
from typing import *

from dataclasses_json import DataClassJsonMixin
from functional import Some, OptionNone
from typing.io import *

from openapi_parser.model import ModelClass, ModelSchema, HavingDescription, HavingPath
from openapi_parser.parser import EnumFilter, find_filters
from .abstract_writer import Writer, yielder, writer
from .footer_writer import Exporting

class ClassWriter(Exporting, Writer):
    def dump_class_description(self, cls: HavingDescription, *, cls_all_required_properties: List[str] = None) -> Iterator[str]:
        if (cls_all_required_properties is None):
            if (isinstance(cls, ModelClass)):
                cls_all_required_properties = cls.all_required_properties
            else:
                cls_all_required_properties = list()
        
        yield self.TRIPLE_QUOT
        
        if (cls.title is not None):
            yield from cls.title.splitlines()
            yield
        
        if (cls.description is not None):
            yield from cls.description.splitlines()
            yield
        
        if (cls_all_required_properties):
            yield "Required Properties:"
            yield from (f" - {self.object_valid_name_filter(self.field_name_pretty(f_name))}" for f_name in cls_all_required_properties)
            yield
        
        if (cls.example is not None):
            example = cls.example
            if (not isinstance(example, str)):
                example = json.dumps(example, indent=self.INDENT_SIZE)
            
            yield "Example:"
            with self.indent():
                yield self.TRIPLE_BACKQUOT + 'json'
                yield from example.splitlines()
                yield self.TRIPLE_BACKQUOT
            yield
        
        yield "Generated by Python OpenAPI Parser"
        if (isinstance(cls, HavingPath)):
            yield f"Class {cls.pretty_path}"
            yield f"Schema {cls.path}"
        yield self.TRIPLE_QUOT
        yield
    
    def dump_enum(self, field_name: str, enum_filter: EnumFilter) -> Iterator[str]:
        cls_name = self.object_valid_name_filter(self.class_name_pretty(enum_filter))
        
        self.export(cls_name)
        yield f'class {cls_name}(Enum):'
        with self.indent():
            yield from map(lambda v: f'{self.object_valid_name_filter(self.class_name_pretty(v))} = {v!r}', enum_filter.possible_values)
        yield
    
    def dump_property(self, name: str, prop: ModelSchema, *, only_if_has_default: Optional[bool] = None, is_required: bool = True) -> Iterator[str]:
        f_type = Some(self.class_name_pretty(prop.cls)) if isinstance(prop, ModelSchema) else OptionNone
        f_default = prop.default
        field_name_pretty = self.field_name_pretty(name)
        actual_name = self.object_valid_name_filter(field_name_pretty)
        
        for enum in find_filters(prop.filter, EnumFilter):
            f_type = Some(self.object_valid_name_filter(self.class_name_pretty(enum)))
        
        if (not is_required):
            f_type = f_type.map('Optional[{}]'.format)
            f_default = f_default or (Some(None) if not is_required else OptionNone)
        
        if (only_if_has_default is not None and f_default.is_empty == only_if_has_default):
            return
        
        f_constructor = dict()
        f_constructor_meta = dict()
        if (prop.filter.encoder is not None):
            f_constructor_meta['encoder'] = self.ref_name_pretty(prop.filter.encoder)
        if (prop.filter.decoder is not None):
            f_constructor_meta['decoder'] = self.ref_name_pretty(prop.filter.decoder)
        if (actual_name != field_name_pretty):
            f_constructor_meta['field_name'] = '{!r}'.format(name)
        
        if (f_constructor_meta):
            f_constructor['metadata'] = self.constructor('config', **f_constructor_meta)
        if (prop.default.non_empty and isinstance(prop.default.get, (list, dict, set, tuple))):
            if (f_default.get):
                f_constructor['default_factory'] = f'lambda: {prop.default.get!r}'
            else:
                f_constructor['default_factory'] = type(prop.default.get).__name__
        if (f_constructor):
            if (f_default.non_empty):
                if ('default_factory' not in f_constructor):
                    f_constructor['default'] = '{!r}'.format(f_default.get)
            f_value = Some(self.constructor('field', **f_constructor))
        else:
            f_value = f_default.map('{!r}'.format)
        
        yield actual_name + f_type.map(': {}'.format).get_or_else('') + f_value.map(' = {}'.format).get_or_else('')
    
    def dump_class(self, cls: ModelClass) -> Tuple[List[str], Iterator[str]]:
        cls_name = self.object_valid_name_filter(self.class_name_pretty(cls))
        cls_all_req_properties = cls.all_required_properties
        
        for f_name, f_data in cls.properties.items():
            for enum in find_filters(f_data.filter, EnumFilter):
                yield from self.dump_enum(f_name, enum)
        
        dataclass_json_config = dict()
        dataclass_json_config['letter_case'] = 'LetterCase.CAMEL'
        self.export(cls_name)
        yield self.constructor('@dataclass_json', **dataclass_json_config)
        yield '@dataclass'
        yield f"class {cls_name}({', '.join(self.object_valid_name_filter(self.class_name_pretty(p)) for p in (cls.parents + [ DataClassJsonMixin ]))}):"
        
        with self.indent():
            yield from self.dump_class_description(cls, cls_all_required_properties=cls_all_req_properties)
            for f_name, f_data in cls.all_properties_iter:
                yield from self.dump_property(f_name, f_data, only_if_has_default=False, is_required=f_name in cls_all_req_properties)
            for f_name, f_data in cls.all_properties_iter:
                yield from self.dump_property(f_name, f_data, only_if_has_default=True, is_required=f_name in cls_all_req_properties)
        
        yield
    
    # region Writers
    @yielder
    def yield_class(self, cls: ModelClass) -> Iterator[Tuple[int, str]]:
        # noinspection PyTypeChecker
        return self.dump_class(cls)
    
    @overload
    def write_class(self, cls: ModelClass) -> Iterator[str]:
        pass
    # noinspection PyOverloads
    @overload
    def write_class(self, cls: ModelClass, *, file: TextIO) -> None:
        pass
    @writer
    def write_class(self, cls: ModelClass) -> Optional[Iterator[str]]:
        # noinspection PyTypeChecker
        return self.yield_class(cls)
    # endregion


__all__ = \
[
    'ClassWriter',
]
